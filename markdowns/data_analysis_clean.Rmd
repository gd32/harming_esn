---
title: "Untitled"
author: "George Dewey, Ryo Ikesu, Akihiro Nishi"
date: "`r Sys.Date()`"
output: html_document
---

---
title: "Evolution of Peace in Experimental Social Networks"
subtitle: "Data Analysis"
author: "George Dewey, Akihiro Nishi"
output: html_document
---

```{r setup, include="FALSE"}
knitr::opts_chunk$set(echo = T, message = F, warning = F, fig.align = "center", tidy.opts=list(width.cutoff=80), tidy=TRUE)
```

# Data Management and Cleaning

## Load packages

```{r, message = F, warning = F}
library(tidyverse) # for data management
library(lme4) # for mixed model regression
library(reldist) # to calculate gini
library(lmerTest)
library(rgeolocate)
library(igraph) # for network analysis
library(reshape2)
```

## Data Processing

```{r}
# Main data: mdata3
load("~/Documents/Projects/harming_esn/Data/mdata3.Rdata")
```

### Set up convenience functions

```{r}
standardize = function(x) {
  mu = mean(x, na.rm = T)
  sd = sd(x, na.rm = T) 
  return ((x - mu)/sd)
}

mean1 = function(x) {mean(x,na.rm=TRUE)} 
```

## Data management

```{r}
harmdata = mdata3

# Renaming current rates
harmdata = harmdata %>% rename(local_rate_coop = cur_local_rate_coop, 
                    local_rate_defect = cur_local_rate_defect,
                    local_rate_punish = cur_local_rate_punish,
                    initial_defect = inital_defect)

# Create continuous happiness variable
harmdata$happ = ifelse(harmdata$satisfaction == "v_good", 2, 
                 ifelse(harmdata$satisfaction == "good", 1, 
                 ifelse(harmdata$satisfaction == "neutral", 0,
                 ifelse(harmdata$satisfaction == "bad", -1, 
                 ifelse(harmdata$satisfaction == "v_bad", -2, NA)))))

# Create positive wealth variable
harmdata$PosWealth = ifelse(harmdata$cumulativePayoff >= 0, 
                            harmdata$cumulativePayoff, 0)

# Create categorical WealthLevel (5 levels)
harmdata = harmdata %>%
  mutate(WealthLevel = case_when(cPayoffS < -1.5 ~ "Poorest",
                                 cPayoffS >= -1.5 & cPayoffS < -0.5  ~ "Poorer",
                                 cPayoffS >= -0.5 & cPayoffS < 0.5  ~ "Middle",
                                 cPayoffS >= 0.5 & cPayoffS < 1.5  ~ "Richer",
                                 cPayoffS >= 1.5  ~ "Richest"))

# Create wealth visibility
harmdata$showScore = ifelse(harmdata$showScore=="true",1,0)

# Matching names over the two data
harmdata = harmdata[,!(names(harmdata) == "gameNumber")]

# Other variables
harmdata$age = as.numeric(unlist(harmdata$age))
harmdata$gender = as.character(unlist(harmdata$gender))
harmdata$ipAddress = as.character(unlist(harmdata$ipAddress))

# Convert IPaddress to country
library(rgeolocate)
file = system.file("extdata","GeoLite2-Country.mmdb", package = "rgeolocate")
ipCountries = maxmind(harmdata$ipAddress, file, "country_name")
harmdata$country = ipCountries$country_name

# Convert country to categorical
`%notin%` <- Negate(`%in%`)

harmdata = harmdata %>% 
  mutate(country_3cat = factor(case_when(country == "United States" ~ "US",
                                         country == "India" ~ "India",
                                         country %notin% c("United States", "India") ~ "Other"),
                               levels = c("US", "India", "Other")))

# Save the individual level data without lag
save(harmdata, file = "~/Documents/Projects/harming_esn/Data/harmdata.RData")
              
# Making data0 - base dataset for regression
data0 = harmdata %>% dplyr::select(game, superid, round, age, gender, 
                                   country_3cat, showScore, initial_score, 
                                   payoff, cumulativePayoff, cPayoffS, 
                                   WealthLevel, behavior_coop, behavior_defect, 
                                   behavior_punish, local_rate_coop, 
                                   local_rate_defect, local_rate_punish, happ, 
                                   behaviorTime, degree, e_degree, initial_coop,
                                   initial_defect, initial_punish)

# Making lag data
data_lag = data0 %>% dplyr::select(superid, round, initial_score, payoff, 
                                   cumulativePayoff, cPayoffS, WealthLevel, 
                                   behavior_coop, local_rate_coop, 
                                   behavior_defect, local_rate_defect, 
                                   behavior_punish, local_rate_punish, 
                                   degree, happ, behaviorTime)

names(data_lag)[-c(1,2)] = paste0(names(data_lag)[-c(1,2)],"_lag")
data_lag$round = data_lag$round + 1

data_lag2 = data0 %>%  dplyr::select(superid, round, initial_score, payoff, 
                                   cumulativePayoff, cPayoffS, WealthLevel, 
                                   behavior_coop, local_rate_coop, 
                                   behavior_defect, local_rate_defect, 
                                   behavior_punish, local_rate_punish, 
                                   degree, happ, behaviorTime)
names(data_lag2)[-c(1,2)] = paste0(names(data_lag2)[-c(1,2)],"_lag2")
data_lag2$round = data_lag2$round + 2

# Merging
# Combine the lag data
data_lag_long = merge(x = data_lag, y = data_lag2, by = c("superid", "round"))

# Merge with current round data
data1 = merge(x=data0,y=data_lag_long,all.x=T,all.y=F,by=c("superid","round"))

# Transform behavior time to log scale
data1$log_behaviorTime = log10(data1$behaviorTime)
data1$log_behaviorTime_lag = log10(data1$behaviorTime_lag)

# Create categorical behavior
data1 = data1 %>% mutate(behavior = case_when(behavior_coop == 1 ~ "C",
                                      behavior_defect == 1 ~ "D",
                                      behavior_punish == 1 ~ "P"),
                 behavior_lag = case_when(behavior_coop_lag == 1 ~ "C",
                                          behavior_defect_lag ==1 ~ "D",
                                          behavior_punish_lag == 1 ~ "P"),
                 behavior_lag2 = case_when(behavior_coop_lag2 == 1 ~ "C",
                                           behavior_defect_lag2 == 1 ~ "D",
                                           behavior_punish_lag2 == 1 ~ "P"))

data1[data1$superid == 2214, "age"] = NA # outlier

# Adding initial centrality measures
load("~/Documents/Projects/harming_esn/Data/harming_jsons/ldata4_0316X.Rdata") #ldata4
load("~/Documents/Projects/harming_esn/Data/ndata_individual.Rdata") #ndata1

cent_df = tibble(superid = NULL,
                 starting_ec = NULL,
                 starting_dc = NULL)
for(i in 1:50){
  ndata_r0 = ndata1 %>% filter(game == i, round == 0) %>% relocate(id)
  r0_el = ldata4 %>% filter(game == i, round == 0) %>% select(id1, id2)
  g = graph_from_data_frame(r0_el, directed = T, vertices = ndata_r0)
  tmp_df = tibble(superid = 100*i+parse_number(names(eigen_centrality(g)$vector)),
                  starting_ec = eigen_centrality(g)$vector,
                  starting_dc = degree(g))
  cent_df = rbind(cent_df, tmp_df)
}

data1 = merge(data1, cent_df, by = "superid")

#replace NaNs (from missing lag data) with NAs
data1[is.na(data1) == T] = NA
save(data1, file = "~/Documents/Projects/harming_esn/Data/data1.Rdata")
```

## Calculate basic statistics about the games

```{r}
# Checking sample sizes
dim(mdata3) #10727 recorded actions
length(unique(mdata3$superid)) #745 unique participants

# Demographics
demo_df = harmdata %>% filter(round == 2)
length(harmdata %>% filter(round == 2) %>% pull(unique(superid))) 
#713 individuals through round 2

# Age
mean(demo_df$age, na.rm = T) #32.86 years old

# Gender
xtabs(~gender, demo_df) # 499 provided gender, F: 206 (41%) vs M: 392 (59%)

# Country
xtabs(~country_3cat, demo_df) #408 (57%) US, 257 (36%) India, 7% Other
length(unique(harmdata$country))

# Behavior time
mean(harmdata$behaviorTime, na.rm = T) #~7870 ms

# Behaviors
xtabs(~behavior_punish + behavior_defect + behavior_coop, harmdata)

# How many peaceful/war-like rounds
peace_rounds = NULL
punish_rounds = NULL
for(i in 1:50){
  tmp = harmdata %>% filter(game == i, round !=0) %>% group_by(round) %>% 
  tally(behavior_punish) %>% group_by(n) %>% summarize(round_count = n())
  peace_rounds = c(peace_rounds, 
                   sum(tmp %>% filter(n == 0) %>% pull(round_count)))
  punish_rounds = c(punish_rounds, 
                    sum(tmp %>% filter(n != 0) %>% pull(round_count)))
}

sum(peace_rounds) #377 rounds with no punish choice
sum(punish_rounds) #373 rounds with at least 1 punish choice
```

# Analysis

## Creating the complete case data

```{r}
data1b = data1 
data1_cc = na.omit(data1b)
dim(data1_cc)
```

## Regression Models for Punishment

We use logistic mixed models with choosing to punish as the outcome and game and user ID (`superid`) as clustering variables. We only include observations with the full set of variables recorded (complete case analysis). 

### Model 1: Including both log behavior time and lag behavior time

```{r}
m1 = glmer(behavior_punish ~ showScore + age + gender + behavior_coop_lag + local_rate_coop_lag + behavior_punish_lag + local_rate_punish_lag + cPayoffS_lag + degree_lag + happ_lag + log_behaviorTime + log_behaviorTime_lag + factor(round) + (1|game) + (1|superid), data = data1_cc, family = binomial, nAGQ=0, control = glmerControl(optimizer = c("bobyqa"), optCtrl=list(maxfun=2e5), calc.derivs=FALSE))

se = sqrt(diag(vcov(m1)))
# table of estimates with 95% CI
tab_m1 = cbind(Est = fixef(m1), LL = fixef(m1) - 1.96 * se, UL = fixef(m1) + 1.96 * se)
round(exp(tab_m1), digits = 3)[1:13,]
```

### Model 2: Only including log behavior time

```{r}
m2 = glmer(behavior_punish ~ showScore + age + gender + behavior_coop_lag + local_rate_coop_lag + behavior_punish_lag + local_rate_punish_lag + cPayoffS_lag + degree_lag + happ_lag + log_behaviorTime  + factor(round) + (1|game) + (1|superid), data = data1_cc, family = binomial, nAGQ=0, control = glmerControl(optimizer = c("bobyqa"), optCtrl=list(maxfun=2e5), calc.derivs=FALSE))
se = sqrt(diag(vcov(m2)))
# table of estimates with 95% CI
tab_m2 = cbind(Est = fixef(m2), LL = fixef(m2) - 1.96 * se, UL = fixef(m2) + 1.96 * se)
round(exp(tab_m2), digits = 3)[1:12,]
```

### Model 3: Without behavior time

```{r}
m3 = glmer(behavior_punish ~ showScore + age + gender + behavior_coop_lag + local_rate_coop_lag + behavior_punish_lag + local_rate_punish_lag + cPayoffS_lag + degree_lag + happ_lag+ factor(round) + (1|game) + (1|superid), data = data1_cc, family = binomial, nAGQ=0, control = glmerControl(optimizer = c("bobyqa"), optCtrl=list(maxfun=2e5), calc.derivs=FALSE))
se = sqrt(diag(vcov(m3)))
# table of estimates with 95% CI
tab_m3 = cbind(Est = fixef(m3), LL = fixef(m3) - 1.96 * se, UL = fixef(m3) + 1.96 * se)
round(exp(tab_m3), digits = 3)[1:11,]
```

### Model 4: Using categorical local punish rate

```{r}
data1_cc$local_rate_punish_cat = case_when(data1_cc$local_rate_punish_lag == 0 ~ 0,
                                          data1_cc$local_rate_punish_lag > 0 & data1_cc$local_rate_punish_lag <= 0.15 ~ 1,
                                          data1_cc$local_rate_punish_lag > 0.15 ~ 2)

m3_cat = glmer(behavior_punish ~ showScore + age + gender + behavior_coop_lag + local_rate_coop_lag + behavior_punish_lag + factor(local_rate_punish_cat) +  cPayoffS_lag + degree_lag + happ_lag + factor(round) + (1|game) + (1|superid), data = data1_cc, family = binomial, nAGQ=0, control = glmerControl(optimizer = c("bobyqa"), optCtrl=list(maxfun=2e5), calc.derivs=FALSE))
se = sqrt(diag(vcov(m3_cat)))
# table of estimates with 95% CI
tab_m3cat = cbind(Est = fixef(m3_cat), LL = fixef(m3_cat) - 1.96 * se, UL = fixef(m3_cat) + 1.96 * se)
round(exp(tab_m3cat), digits = 3)[1:12,]
```

### Model 5: Crude model for the experimental condition (`showScore`).

```{r}
m3_tmp = glmer(behavior_punish ~ showScore + factor(round) + (1|game) + (1|superid), data = data1_cc, family = binomial, nAGQ=0, control = glmerControl(optimizer = c("bobyqa"), optCtrl=list(maxfun=2e5), calc.derivs=FALSE))
se = sqrt(diag(vcov(m3_tmp)))
# table of estimates with 95% CI
tab_m3tmp = cbind(Est = fixef(m3_tmp), LL = fixef(m3_tmp) - 1.96 * se, UL = fixef(m3_tmp) + 1.96 * se)
round(exp(tab_m3tmp), digits = 3)[1:12,]
```

### Model 6: Adding additional categories, treating local cooperation rate from the previous round as categorical

We use 6 categories for cooperation and punishment.

```{r}

data1_cc$local_rate_punish_cat4 = 
  case_when(data1_cc$local_rate_punish_lag >=0 & data1_cc$local_rate_punish_lag <= 0.05 ~ 0,
            data1_cc$local_rate_punish_lag >0.05 & data1_cc$local_rate_punish_lag <= 0.1 ~ 1,
            data1_cc$local_rate_punish_lag > 0.1 & data1_cc$local_rate_punish_lag <= 0.15 ~ 2,
            data1_cc$local_rate_punish_lag > 0.15 & data1_cc$local_rate_punish_lag <= 0.2 ~ 3,
            data1_cc$local_rate_punish_lag > 0.2 & data1_cc$local_rate_punish_lag <= 0.25 ~ 4,
            data1_cc$local_rate_punish_lag > 0.25 ~ 5)

data1_cc$local_rate_coop_cat4 = 
  case_when(data1_cc$local_rate_coop_lag > 0 & data1_cc$local_rate_coop_lag <= 0.1 ~ 4,
            data1_cc$local_rate_coop_lag > 0.1 & data1_cc$local_rate_coop_lag <= 0.3 ~ 3,
            data1_cc$local_rate_coop_lag > 0. & data1_cc$local_rate_coop_lag <= 0.6 ~ 2,
            data1_cc$local_rate_coop_lag > 0.6 & data1_cc$local_rate_coop_lag <= 0.8 ~ 1,
            data1_cc$local_rate_coop_lag > 0.8  ~ 0)

round(addmargins(prop.table(xtabs(~local_rate_coop_cat4 + behavior_punish, data1_cc))), digits = 3)

round(addmargins(prop.table(xtabs(~local_rate_coop_cat4 + behavior_punish, data1_cc), margin = 1), margin = 2), digits = 3)
```

```{r}
m3_cat4 = glmer(behavior_punish ~ showScore + age + gender + behavior_coop_lag + local_rate_coop_lag + behavior_punish_lag + factor(local_rate_punish_cat4) + cPayoffS_lag + degree_lag + happ_lag + factor(round) + (1|game) + (1|superid), data = data1_cc, family = binomial, nAGQ=0, control = glmerControl(optimizer = c("bobyqa"), optCtrl=list(maxfun=2e5), calc.derivs=FALSE))

summary(m3_cat4)

se = sqrt(diag(vcov(m3_cat4)))
# table of estimates with 95% CI
tab_m3_cat4 = cbind(Est = fixef(m3_cat4), LL = fixef(m3_cat4) - 1.96 * se, UL = fixef(m3_cat4) + 1.96 * se)
round(exp(tab_m3_cat4), digits = 3)[1:19,]
```

### Model 7: Crude model for only categorical punish rate

```{r}
# Change to ryo's categories
m4 = glmer(behavior_punish ~ factor(local_rate_punish_cat4) + factor(round) + (1|game) + (1|superid), data = data1_cc, family = binomial, nAGQ=0, control = glmerControl(optimizer = c("bobyqa"), optCtrl=list(maxfun=2e5), calc.derivs=FALSE))
se = sqrt(diag(vcov(m4)))
# table of estimates with 95% CI
tab = cbind(Est = fixef(m4), LL = fixef(m4) - 1.96 * se, UL = fixef(m4) + 1.96 * se)
round(exp(tab), digits = 3)[1:6,]
```

### Model 8: Crude model for only categorical cooperation rate

```{r}
m5 = glmer(behavior_punish ~ factor(local_rate_coop_cat4) + factor(round) + (1|game) + (1|superid), data = data1_cc, family = binomial, nAGQ=0, control = glmerControl(optimizer = c("bobyqa"), optCtrl=list(maxfun=2e5), calc.derivs=FALSE))
se = sqrt(diag(vcov(m5)))
# table of estimates with 95% CI
tab = cbind(Est = fixef(m5), LL = fixef(m5) - 1.96 * se, UL = fixef(m5) + 1.96 * se)
round(exp(tab), digits = 3)[1:6,]
```

### Model 9: Stratified regression for different game "phases"

#### Full models

```{r}
data1_early = data1_cc %>% filter(round %in% 2:5)
data1_mid = data1_cc %>% filter(round %in% 6:10)
data1_late = data1_cc %>% filter(round %in% 11:15)

# Early - using the full model
m9early = glmer(behavior_punish ~ showScore + age + gender + behavior_coop_lag + factor(local_rate_coop_cat4) + behavior_punish_lag + factor(local_rate_punish_cat4) + cPayoffS_lag + degree_lag + happ_lag + factor(round) + (1|game) + (1|superid), data = data1_early, family = binomial, nAGQ=0, control = glmerControl(optimizer = c("bobyqa"), optCtrl=list(maxfun=2e5), calc.derivs=FALSE))
se = sqrt(diag(vcov(m9early)))
# table of estimates with 95% CI
tab = cbind(Est = fixef(m9early), LL = fixef(m9early) - 1.96 * se, UL = fixef(m9early) + 1.96 * se)
round(exp(tab), digits = 3)[1:18,]

# Mid
m9mid = glmer(behavior_punish ~ showScore + age + gender + behavior_coop_lag + factor(local_rate_coop_cat4) + behavior_punish_lag + factor(local_rate_punish_cat4) + cPayoffS_lag + degree_lag + happ_lag + factor(round) + (1|game) + (1|superid), data = data1_mid, family = binomial, nAGQ=0, control = glmerControl(optimizer = c("bobyqa"), optCtrl=list(maxfun=2e5), calc.derivs=FALSE))
se = sqrt(diag(vcov(m9mid)))
# table of estimates with 95% CI
tab = cbind(Est = fixef(m9mid), LL = fixef(m9mid) - 1.96 * se, UL = fixef(m9mid) + 1.96 * se)
round(exp(tab), digits = 3)[1:18,]

# Late
m9late = glmer(behavior_punish ~ showScore + age + gender + behavior_coop_lag + factor(local_rate_coop_cat4) + behavior_punish_lag + factor(local_rate_punish_cat4) + cPayoffS_lag + degree_lag + happ_lag + factor(round) + (1|game) + (1|superid), data = data1_late, family = binomial, nAGQ=0, control = glmerControl(optimizer = c("bobyqa"), optCtrl=list(maxfun=2e5), calc.derivs=FALSE))
se = sqrt(diag(vcov(m9late)))
# table of estimates with 95% CI
tab = cbind(Est = fixef(m9late), LL = fixef(m9late) - 1.96 * se, UL = fixef(m9late) + 1.96 * se)
round(exp(tab), digits = 3)[1:18,]
```
#### Crude models for showScore

```{r}
# Early
m9early = glmer(behavior_punish ~ showScore + factor(round) + (1|game) + (1|superid), data = data1_early, family = binomial, nAGQ=0, control = glmerControl(optimizer = c("bobyqa"), optCtrl=list(maxfun=2e5), calc.derivs=FALSE))
se = sqrt(diag(vcov(m9early)))
# table of estimates with 95% CI
tab = cbind(Est = fixef(m9early), LL = fixef(m9early) - 1.96 * se, UL = fixef(m9early) + 1.96 * se)
round(exp(tab), digits = 3)
summary(m9early)
```
```{r}
# Mid
m9mid = glmer(behavior_punish ~ showScore + factor(round) + (1|game) + (1|superid), data = data1_mid, family = binomial, nAGQ=0, control = glmerControl(optimizer = c("bobyqa"), optCtrl=list(maxfun=2e5), calc.derivs=FALSE))
se = sqrt(diag(vcov(m9mid)))
# table of estimates with 95% CI
tab = cbind(Est = fixef(m9mid), LL = fixef(m9mid) - 1.96 * se, UL = fixef(m9mid) + 1.96 * se)
round(exp(tab), digits = 3) 
summary(m9mid)
```

```{r}
# Late
m9late = glmer(behavior_punish ~ showScore + factor(round) + (1|game) + (1|superid), data = data1_late, family = binomial, nAGQ=0, control = glmerControl(optimizer = c("bobyqa"), optCtrl=list(maxfun=2e5), calc.derivs=FALSE))
se = sqrt(diag(vcov(m9late)))
# table of estimates with 95% CI
tab = cbind(Est = fixef(m9late), LL = fixef(m9late) - 1.96 * se, UL = fixef(m9late) + 1.96 * se)
round(exp(tab), digits = 3)
summary(m9late)
```

## Group selection dynamics

Among the 50 sessions, some are harming-rich (overall $\ge$ 10% of decisions are harming) sessions, while some others are harming-less. You make categories (2 to 4?) based on the magnitude of harming-rich-less, and calculate the average cumulative payoff at the end of session. Determine which category achieves higher average cumulative payoff? Show boxplot with raw-data dots? -\> See Gachter 2008 Science

```{r}
library(reshape2)
data1_groups = data1 %>% group_by(game) %>% 
  count(behavior_punish, sort = F) %>% 
  dcast(formula = game ~ behavior_punish, value.var = "n") 
names(data1_groups) = c("game", "no_harm", "harm")
data1_groups = data1_groups %>% mutate(harm = ifelse(is.na(harm) == T, 0, harm),
                        harm_rate = round(harm/no_harm, 3))

hist(data1_groups$harm_rate)
data1_groups = data1_groups %>% mutate(harm_rate_cat = case_when(harm_rate >= 0 & harm_rate < 0.025 ~ 0,
                                                  harm_rate >= 0.025 & harm_rate <0.05 ~ 1,
                                                  harm_rate >= 0.05 & harm_rate < 0.1 ~ 2,
                                                  harm_rate >= 0.1 ~ 3))
xtabs(~harm_rate_cat, data1_groups)

harm_cat0 = data1_groups %>% filter(harm_rate_cat == 0) %>% pull(game)
harm_cat1 = data1_groups %>% filter(harm_rate_cat == 1) %>% pull(game)
harm_cat2 = data1_groups %>% filter(harm_rate_cat == 2) %>% pull(game)
harm_cat3 = data1_groups %>% filter(harm_rate_cat == 3) %>% pull(game)
```

```{r}
data1 %>% group_by(game) %>%
  filter(round !=0) %>% 
  group_by(game, round) %>%
  summarize(mean_payoff = mean(cumulativePayoff)) %>%
  mutate(harm_category = case_when(game %in% harm_cat0 ~ 1,
                                   game %in% harm_cat1 ~ 2,
                                   game %in% harm_cat2 ~ 3,
                                   game %in% harm_cat3 ~ 4)) %>%
  ggplot() +
  geom_line(aes(x = round, y = mean_payoff, group = game, 
                color = factor(harm_category))) +
  scale_color_brewer(palette = "Spectral") +
  scale_x_continuous(breaks = c(1, 3, 5, 7, 9, 11, 13, 15))

data1 %>% group_by(game) %>%
  filter(round !=0) %>% 
  group_by(game, round) %>%
  summarize(mean_payoff = mean(cumulativePayoff)) %>%
  mutate(harm_category = case_when(game %in% harm_cat0 ~ 1,
                                   game %in% harm_cat1 ~ 2,
                                   game %in% harm_cat2 ~ 3,
                                   game %in% harm_cat3 ~ 4)) %>%
  filter(round == 15) %>%
  group_by(harm_category) %>%
  summarize(mean_payoff_by_harmcat = mean(mean_payoff))
```

## Examining the other variables which were randomized (network structure, initial score)

### Inital Score

```{r}
data1_4 = data1 %>% group_by(game) %>% 
  filter(round == 0) %>% 
  mutate(init_score_indicator = ifelse(initial_score == 200, "low", "high"),
         harm_category = case_when(game %in% harm_cat0 ~ 1,
                                   game %in% harm_cat1 ~ 2,
                                   game %in% harm_cat2 ~ 3,
                                   game %in% harm_cat3 ~ 4))

# Can we use the percentage of high initial scores? (or lows)
data1_4 %>% 
  count(init_score_indicator, sort = F) %>% 
  dcast(formula = game ~ init_score_indicator, value.var = "n") %>%
  mutate(perc_high = high/(high+low),
         harm_category = case_when(game %in% harm_cat0 ~ 1,
                                   game %in% harm_cat1 ~ 2,
                                   game %in% harm_cat2 ~ 3,
                                   game %in% harm_cat3 ~ 4)) %>%
  ggplot() + 
  geom_boxplot(aes(x=factor(harm_category),y=low)) #high/low is the number of people with initial score 1150/200
# don't see much of a trend
xtabs(~init_score_indicator data1_4)
round(addmargins(prop.table(xtabs(~harm_category + init_score_indicator, data1_4), margin = 2), margin = 2), digits = 3)
```

### Centrality measures (eigenvector and degree centrality)

### Model 8: Full model including centrality

```{r}
m5 = glmer(behavior_punish ~ showScore + age + gender + starting_ec + starting_dc + factor(initial_score) + behavior_coop_lag + local_rate_coop_lag + behavior_punish_lag + factor(local_rate_punish_cat) + cPayoffS_lag + degree_lag + happ_lag + log_behaviorTime + factor(round) + (1|game) + (1|superid), data = data1_cc, family = binomial, nAGQ=0, control = glmerControl(optimizer = c("bobyqa"), optCtrl=list(maxfun=2e5), calc.derivs=FALSE))

se = sqrt(diag(vcov(m5)))
# table of estimates with 95% CI
tab_m5 = cbind(Est = fixef(m5), LL = fixef(m5) - 1.96 * se, UL = fixef(m5) + 1.96 * se)
round(exp(tab_m5), digits = 3)[1:16,]
```

## Relationship between punishment and decision time

From regressions, the behavior time variable was significant. Here we check if punishment is generally slow or if there is something else influencing this association.

### Contingency table for behavior time

```{r}
hist(data1$log_behaviorTime)
quantile(data1$log_behaviorTime, na.rm = T)
quantile(data1_cc$log_behaviorTime)
data1_cc$behaviorTime_cat = case_when(data1_cc$log_behaviorTime >= 3 & data1_cc$log_behaviorTime < 3.4 ~ 0,
                                      data1_cc$log_behaviorTime >= 3.4 & data1_cc$log_behaviorTime < 3.6 ~ 1,
                                      data1_cc$log_behaviorTime >= 3.6 & data1_cc$log_behaviorTime < 3.9 ~ 2,
                                      data1_cc$log_behaviorTime >= 3.9 ~ 3)

round(addmargins(prop.table(xtabs(~behaviorTime_cat + behavior_punish, data1_cc), margin = 1), margin = 2), digits = 3)
round(addmargins(prop.table(xtabs(~behaviorTime_cat + behavior_coop, data1_cc), margin = 1), margin = 2), digits = 3)

data1 %>%
  na.omit() %>%
  ggplot() +
  geom_boxplot(aes(x=behavior, y=log_behaviorTime)) +
  theme_minimal() +
  xlab("Behavior") +
  ylab("log Decision Time") +
  scale_x_discrete(labels = c("Cooperate", "Defect", "Punish"))
```

### Means

```{r}
summary(data1[is.na(data1$behaviorTime)==0 & data1$behaviorTime>=1000 & data1$behaviorTime<3000,]$behavior_coop)
#0.56
summary(data1[is.na(data1$behaviorTime)==0 & data1$behaviorTime>=3000 & data1$behaviorTime<5000,]$behavior_coop)
#0.49
summary(data1[is.na(data1$behaviorTime)==0 & data1$behaviorTime>=5000 & data1$behaviorTime<9000,]$behavior_coop)
#0.49
summary(data1[is.na(data1$behaviorTime)==0 & data1$behaviorTime>=9000 & data1$behaviorTime<1000000,]$behavior_coop)
#0.47

summary(data1[is.na(data1$behaviorTime)==0 & data1$behaviorTime>=1000 & data1$behaviorTime<3000,]$behavior_punish)
#0.03
summary(data1[is.na(data1$behaviorTime)==0 & data1$behaviorTime>=3000 & data1$behaviorTime<5000,]$behavior_punish)
#0.047
summary(data1[is.na(data1$behaviorTime)==0 & data1$behaviorTime>=5000 & data1$behaviorTime<9000,]$behavior_punish)
#0.069
summary(data1[is.na(data1$behaviorTime)==0 & data1$behaviorTime>=9000 & data1$behaviorTime<1000000,]$behavior_punish)
#0.079
```

## Evaluating war-state in networks

```{r}
library(tidyverse)
library(lme4)

# Load data
load("~/Documents/Projects/harming_esn/Data/harmdata.Rdata") #harmdata

# First checking how many rounds have a punishment choice
peace_rounds = NULL
punish_rounds = NULL
for(i in 1:50){
  tmp = harmdata %>% filter(game == i, round !=0) %>% group_by(round) %>% 
    tally(behavior_punish) %>% group_by(n) %>% summarize(round_count = n())
  peace_rounds = c(peace_rounds, 
                   sum(tmp %>% filter(n == 0) %>% pull(round_count)))
  punish_rounds = c(punish_rounds, 
                    sum(tmp %>% filter(n != 0) %>% pull(round_count)))
}
sum(peace_rounds) #377 rounds with no punish choice
sum(punish_rounds) #373 rounds with at least 1 punish choice

tmp = harmdata %>% filter(game == 1, round !=0) %>% group_by(round) %>% tally(behavior_punish) %>% pull(n)

subseq_check <- function(x,y) grepl(toString(y),toString(x),fixed = TRUE)
subseq_check(tmp, c("0", "0", "0", "0", "0"))
peace_str = c("0", "0", "0", "0", "0")

peace_games = NULL
war_games = NULL
for(i in 1:50){
  tmp = harmdata %>% filter(game == i, round !=0) %>% group_by(round) %>% 
    tally(behavior_punish) %>% pull(n)
  if(subseq_check(tail(tmp, 5), peace_str) == T){
    peace_games = c(peace_games, i)
  } else {
    war_games = c(war_games, i)
  }
}

length(peace_games) #14 games had peace (last 5 rounds had no punishment)

punish_counts = NULL
for(i in peace_games){
  tmp = harmdata %>% filter(game == i, round !=0) %>% group_by(round) %>% 
    tally(behavior_punish) %>% pull(n)
  punish_counts = cbind(punish_counts, tmp)
}
names(punish_counts) = as.character(peace_games)
punish_counts = as.data.frame(punish_counts)
punish_counts
punish_counts %>%
  rownames_to_column() %>%
  gather(colname, value, -rowname) %>%
  ggplot(aes(x = as.numeric(rowname), y = colname, fill = value)) +
  geom_tile() +
  xlab("Round") + ylab("Game ID")

# get the number of punishments per game
pun_counts = harmdata %>% 
  group_by(game) %>%
  tally(behavior_punish) %>%
  rename(punishments = n)

netdata = harmdata %>% 
  group_by(game) %>%
  select(superid, game, round, showScore, behavior_coop, behavior_defect, 
         behavior_punish,cPayoffS, behaviorTime, degree, rate_coop, rate_rich, 
         local_gini, initial_coop, initial_defect, initial_punish, initial_local_gini, 
         initial_degree, happ, WealthLevel, country) %>%
  arrange(game, round, superid) %>%
  mutate(peace_game = ifelse(game %in% peace_games, 1, 0)) %>%
  summarize(showScore = mean(showScore),
            n = n(),
            mean_deg = mean(degree, na.rm = T),
            mean_init_deg = mean(initial_degree, na.rm = T),
            prop_punish = mean(behavior_punish, na.rm = T),
            prop_coop = mean(behavior_coop, na.rm = T),
            init_coop = mean(initial_coop, na.rm = T),
            init_punish = mean(initial_punish, na.rm = T),
            mean_gini = mean(initial_local_gini, na.rm = T),
            peace_game = mean(peace_game))

netdata1 = left_join(netdata, pun_counts, by = "game")

#### Regression models ####
## Using binary peace status as the outcome
m0 = glm(peace_game ~ showScore, data = netdata)
summary(m0)

m1 = glm(peace_game ~ showScore + mean_deg +  mean_init_deg + prop_punish + prop_coop + init_punish + init_coop + mean_gini, data = netdata)
summary(m1)

m2 = glm(peace_game ~ showScore + mean_gini + mean_init_deg, data = netdata)
summary(m2)

xtabs(~peace_game + showScore, netdata)

## Using the number of non-peace rounds as the outcome
m3 = lm(punishments ~ showScore, data = netdata1)
summary(m3)

m4 = lm(punishments ~ showScore + mean_gini + mean_init_deg, data = netdata1)
summary(m4)

m5 = lm(punishments ~ showScore + mean_deg +  mean_init_deg + 
         prop_punish + prop_coop + init_punish + init_coop + mean_gini, 
       data = netdata1)
summary(m5)
```


    
## Examining effects of rewiring (in progress)
```{r}
load("~/Documents/Projects/harming_esn/Data/harming_jsons/ldata4_0316X.Rdata") #ldata4
load("~/Documents/Projects/harming_esn/Data/ndata_individual.Rdata") #ndata1
load("~/Documents/Projects/harming_esn/Data/harmdata.Rdata") #harmdata

library(tidyverse)
library(lme4)

#### Unnesting all the lists for rewiring data ####

ndata_break = ndata1 %>% 
  select(breakLink, notMakeLink, notBreakLink, makeLink, round, game, 
         starts_with("id")) %>%
  filter(round != 0) %>%
  mutate(across(starts_with("id"), ~100*game+parse_number(.))) %>%
  unnest_wider(breakLink) %>%
  rename(break1 = ...1,
         break2 = ...2,
         break3 = ...3, 
         break4 = ...4,
         break5 = ...5)

ndata_wide1  = ndata_break %>%
  unnest_wider(notMakeLink) 

names(ndata_wide1)[6:15] = c("notMake1", "notMake2", "notMake3", "notMake4",
                                     "notMake5", "notMake6", "notMake7", "notMake8",
                                     "notMake9", "notMake10")

ndata_wide2 = ndata_wide1 %>%
  unnest_wider(notBreakLink)

names(ndata_wide2)[16:22] = c("noBreak1", "noBreak2", "noBreak3", "noBreak4", 
                             "noBreak5", "noBreak6", "noBreak7")

ndata_wide3 = ndata_wide2 %>%
  unnest_wider(makeLink)

names(ndata_wide3)[23:31] = c("make1", "make2", "make3", "make4", "make5", 
                              "make6", "make7", "make8", "make9")


write.csv(ndata_wide3, "~/Documents/Projects/harming_esn/Data/ndata_wide_rewiring.csv", row.names = F)

# ndata_wide3 = read_csv("~/Documents/Projects/harming_esn/Data/ndata_wide_rewiring.csv")

#### Data management for rewiring analysis ####

ndata_final = ndata_wide3 %>%
  filter(round != 0) %>%
  mutate(across(starts_with("break"), ~100*game+parse_number(.)),
         across(starts_with("no"), ~100*game+parse_number(.)),
         across(starts_with("make"), ~100*game+parse_number(.))) %>%
  pivot_longer(cols = c(starts_with("break"), starts_with("no"), 
                        starts_with("make"))) %>%
  filter(is.na(value) == F) %>% 
  rename(superid = id) %>%
  select(superid, round, game, name, value)

ndata_alters_list = ndata1 %>% 
  select(round, game, starts_with("id")) %>%
  filter(round != 0) %>%
  mutate(across(starts_with("id"), ~100*game+parse_number(.))) %>%
  rename(superid = id)

names(ndata_alters_list)[4:20] = c("alter1", "alter2", "alter3", "alter4", 
                                   "alter5", "alter6", "alter7", "alter8",
                                   "alter9", "alter10", "alter11", "alter12",
                                   "alter13", "alter14", "alter15", "alter16",
                                   "alter17")



# left_join(ndata_final, ndata_alters_list, by = c("superid", "round", "game"))

# Creating lag data for previous alters
ndata_alters_lag = ndata_alters_list
names(ndata_alters_lag)[4:20] = paste0("lag_",names(ndata_alters_lag)[4:20])
ndata_alters_lag$round = ndata_alters_lag$round+1

ndata_alters = merge(ndata_alters_list, ndata_alters_lag, 
                     by = c("superid", "round", "game")) %>%
  arrange(superid, round)

ndata_base = ndata1 %>% 
  select(round, game, starts_with("id")) %>%
  filter(round != 0) %>%
  mutate(across(starts_with("id"), ~100*game+parse_number(.))) %>%
  pivot_longer(cols = starts_with("id2"))  %>%
  na.omit() %>%
  rename(superid = id, alter_id = value) %>%
  select(superid, game, round, alter_id)

left_join(ndata_final, ndata_base, by = c("superid", "game", "round")) %>%
  mutate(retain_tie = ifelse(str_detect(name, "noBreak") == T & value == alter_id, 1, 0),
         no_make_tie = ifelse(str_detect(name "noConn" == T & value == alter_id, 1, 0)),
         break_tie = ifelse(str_detect(name, "break" == T & value == alter_id, 1, 0)),
         )

ndata_nt = left_join(ndata_base, ndata_alters, by = c("round", "game", "superid")) %>%
  filter(round != 1) %>%
  select(superid, game, round, alter_id, starts_with("lag")) %>%
  rowwise %>%
  mutate(new_tie = ifelse(alter_id %in% c_across(starts_with("lag_")), 0, 1))

covars = data1 %>% 
  filter(round != 0) %>%
  select(superid, game, round, showScore, initial_score, behavior_coop,
         behavior_punish, behavior_defect, behavior_coop_lag, 
         behavior_punish_lag, behavior_defect_lag, gender, age, country_3cat,
         WealthLevel, cPayoffS, starting_dc, starting_ec)

alter_behaviors = covars %>% 
  select(superid, game, round, behavior_coop, behavior_punish,
         behavior_defect, behavior_coop_lag, 
         behavior_punish_lag, behavior_defect_lag) %>%
  arrange(game, round) %>%
  rename(alter_id = superid,
         alter_behavior_coop = behavior_coop,
         alter_behavior_punish = behavior_punish,
         alter_behavior_defect = behavior_defect,
         alter_behavior_coop_lag = behavior_coop_lag,
         alter_behavior_punish_lag = behavior_punish_lag,
         alter_behavior_defect_lag = behavior_defect_lag) %>%
  filter(round != 1)

tmp1 = left_join(ndata_nt, covars, by = c("superid", "game", "round")) %>% 
  select(-starts_with("la"))

data6 = left_join(tmp1, alter_behaviors, by = c("alter_id", "game", "round"))


# cross tabs
xtabs(~new_tie, data6)
data6 = data6 %>%
  mutate(behavior = case_when(behavior_coop == 1 ~ "C",
                              behavior_defect == 1 ~ "D",
                              behavior_punish == 1 ~ "P"),
         alter_behavior = case_when(alter_behavior_coop == 1 ~ "C",
                                    alter_behavior_defect == 1 ~ "D",
                                    alter_behavior_punish == 1 ~ "P"),
         behavior_lag = case_when(behavior_coop_lag == 1 ~ "C",
                                  behavior_defect_lag == 1 ~ "D",
                                  behavior_punish_lag == 1 ~ "P"),
         alter_behavior_lag = case_when(alter_behavior_coop_lag == 1 ~ "C",
                                        alter_behavior_defect_lag == 1 ~ "D",
                                        alter_behavior_punish_lag == 1 ~ "P"),
         new_tie = factor(new_tie, levels = c(0, 1)))

# Want to compare the building vs. breaking

names(data6)
# simple regression
m6 = glmer(factor(new_tie, levels = c(1, 0)) ~ showScore + factor(initial_score) + factor(behavior) + factor(alter_behavior) 
       + factor(round) + (1|game) + (1|superid),
      data = data6 , family = binomial, nAGQ=0, 
      control = glmerControl(optimizer = c("bobyqa"), optCtrl=list(maxfun=2e5), calc.derivs=FALSE))
se = sqrt(diag(vcov(m6)))
# table of estimates with 95% CI
tab_m6 = cbind(Est = fixef(m6), LL = fixef(m6) - 1.96 * se, UL = fixef(m6) + 1.96 * se)
round(exp(tab_m6), digits = 3)[1:7,]

# add all the covariates
m6_long = glmer(new_tie ~ showScore + factor(initial_score) + factor(behavior) +
                factor(alter_behavior) + gender + age + country_3cat + 
                WealthLevel + cPayoffS + starting_dc + starting_ec + 
                factor(round) + (1|game) + (1|superid),data = data6 , family = binomial, nAGQ=0, 
                control = glmerControl(optimizer = c("bobyqa"), optCtrl=list(maxfun=2e5), calc.derivs=FALSE))
se = sqrt(diag(vcov(m6_long)))
# table of estimates with 95% CI
tab_m6 = cbind(Est = fixef(m6_long), LL = fixef(m6_long) - 1.96 * se, UL = fixef(m6_long) + 1.96 * se)
round(exp(tab_m6), digits = 3)[1:18,]

```