---
title: "Data Analysis for Harming Experiment"
author: "George Dewey"
date: "4/27/2022"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Data Management + Cleaning

## Load packages

```{r}
library(tidyverse) # for data management
library(Zelig) # for regression
library(lme4) # for mixed model regression
library(reldist) # to calculate gini
library(ggplot2) # for visualization
library(igraph) # for network analysis
library(rgeolocate) # convert IPs to address
```

## Data Processing

```{r}
# Main data: mdata3
load("~/Documents/Projects/harming_esn/Data/mdata3.Rdata")
```

### Set up convenience functions

```{r}
standardize = function(x) {
  mu = mean(x, na.rm = T)
  sd = sd(x, na.rm = T) 
  return ((x - mu)/sd)
}
```

## Data management

```{r}
#Checking id
harmdata = mdata3

# Renaming current rates
harmdata = harmdata %>% rename(local_rate_coop = cur_local_rate_coop, 
                    local_rate_defect = cur_local_rate_defect,
                    local_rate_punish = cur_local_rate_punish,
                    initial_defect = inital_defect)

# Create continuous happiness variable
harmdata$happ = ifelse(harmdata$satisfaction == "v_good", 2, 
                 ifelse(harmdata$satisfaction == "good", 1, 
                 ifelse(harmdata$satisfaction == "neutral", 0,
                 ifelse(harmdata$satisfaction == "bad", -1, 
                 ifelse(harmdata$satisfaction == "v_bad", -2, NA)))))

# Create positive wealth variable
harmdata$PosWealth = ifelse(harmdata$cumulativePayoff >= 0, 
                            harmdata$cumulativePayoff, 0)

# Create categorical WealthLevel (5 levels)
harmdata = harmdata %>%
  mutate(WealthLevel = case_when(cPayoffS < -1.5 ~ "Poorest",
                                 cPayoffS >= -1.5 & cPayoffS < -0.5  ~ "Poorer",
                                 cPayoffS >= -0.5 & cPayoffS < 0.5  ~ "Middle",
                                 cPayoffS >= 0.5 & cPayoffS < 1.5  ~ "Richer",
                                 cPayoffS >= 1.5  ~ "Richest"))

# Create wealth visibility
harmdata$showScore = ifelse(harmdata$showScore=="true",1,0)

###making the variable names the same over the two data
harmdata = harmdata[,!(names(harmdata) == "gameNumber")]

#Other variables
harmdata$age = as.numeric(unlist(harmdata$age))
harmdata$gender = as.character(unlist(harmdata$gender))
harmdata$ipAddress = as.character(unlist(harmdata$ipAddress))

# Convert IPaddress to country
file = system.file("extdata","GeoLite2-Country.mmdb", package = "rgeolocate")
ipCountries = maxmind(harmdata$ipAddress, file, "country_name")
harmdata$country = ipCountries$country_name

`%notin%` <- Negate(`%in%`)

harmdata = harmdata %>% 
  mutate(country_3cat = 
           factor(case_when(country == "United States" ~ "US",
                            country == "India" ~ "India",
                            country %notin% c("United States", 
                                              "India") ~ "Other"),
                            levels = c("US", "India", "Other")))
              
# Making data0 - base dataset for regression
names(harmdata)

data0 = harmdata %>% dplyr::select(game, superid, round, age, gender, 
                                   country_3cat, showScore, initial_score, 
                                   payoff, cumulativePayoff, cPayoffS, 
                                   WealthLevel, behavior_coop, behavior_defect, 
                                   behavior_punish, local_rate_coop, 
                                   local_rate_defect, local_rate_punish, happ, 
                                   behaviorTime, degree, e_degree, initial_coop,
                                   initial_defect, initial_punish)

#Making lag data
data_lag = data0 %>% dplyr::select(superid, round, initial_score, payoff, 
                                   cumulativePayoff, cPayoffS, WealthLevel, 
                                   behavior_coop, local_rate_coop, 
                                   behavior_defect, local_rate_defect, 
                                   behavior_punish, local_rate_punish, 
                                   degree, happ, behaviorTime)

names(data_lag)[-c(1,2)] = paste0(names(data_lag)[-c(1,2)],"_lag")
data_lag$round = data_lag$round + 1

data_lag2 = data0 %>%  dplyr::select(superid, round, initial_score, payoff, 
                                   cumulativePayoff, cPayoffS, WealthLevel, 
                                   behavior_coop, local_rate_coop, 
                                   behavior_defect, local_rate_defect, 
                                   behavior_punish, local_rate_punish, 
                                   degree, happ, behaviorTime)
names(data_lag2)[-c(1,2)] = paste0(names(data_lag2)[-c(1,2)],"_lag2")
data_lag2$round = data_lag2$round + 2

# Merging
# Combine the lag data
data_lag_long = merge(x = data_lag, y = data_lag2, by = c("superid", "round"))

# Merge with current round data
data1 = merge(x=data0,y=data_lag_long,all.x=T,all.y=F,by=c("superid","round"))

# Transform behavior time to log scale
data1$log_behaviorTime = log10(data1$behaviorTime)
data1$log_behaviorTime_lag = log10(data1$behaviorTime_lag)

# Create categorical behavior
data1 = data1 %>% mutate(behavior = case_when(behavior_coop == 1 ~ "C",
                                      behavior_defect == 1 ~ "D",
                                      behavior_punish == 1 ~ "P"),
                 behavior_lag = case_when(behavior_coop_lag == 1 ~ "C",
                                          behavior_defect_lag ==1 ~ "D",
                                          behavior_punish_lag == 1 ~ "P"),
                 behavior_lag2 = case_when(behavior_coop_lag2 == 1 ~ "C",
                                           behavior_defect_lag2 == 1 ~ "D",
                                           behavior_punish_lag2 == 1 ~ "P"))

data1[data1$superid == 2214, "age"] = NA # outlier

# Adding initial centrality measures
load("~/Documents/Projects/harming_esn/Data/harming_jsons/ldata4_0316X.Rdata") #ldata4
load("~/Documents/Projects/harming_esn/Data/ndata_individual.Rdata") #ndata1

cent_df = tibble(superid = NULL,
                 starting_ec = NULL,
                 starting_dc = NULL)
for(i in 1:50){
  ndata_r0 = ndata1 %>% filter(game == i, round == 0) %>% relocate(id)
  r0_el = ldata4 %>% filter(game == i, round == 0) %>% select(id1, id2)
  g = graph_from_data_frame(r0_el, directed = T, vertices = ndata_r0)
  tmp_df = tibble(superid = 100*i+parse_number(names(eigen_centrality(g)$vector)),
                  starting_ec = eigen_centrality(g)$vector,
                  starting_dc = degree(g))
  cent_df = rbind(cent_df, tmp_df)
}

data1 = merge(data1, cent_df, by = "superid")

#replace NaNs (from missing lag data) with NAs
data1[is.na(data1) == T] = NA
```

# Analysis

## 1. What are the characteristics of people who chose to attack (=performing costly sanction)? 

```{r}
# Make the categorical behavior variable
data1b = data1 %>% mutate(behavior = case_when(behavior_coop == 1 ~ "C",
                                      behavior_defect == 1 ~ "D",
                                      behavior_punish == 1 ~ "P"),
                 behavior_lag = case_when(behavior_coop_lag == 1 ~ "C",
                                          behavior_defect_lag ==1 ~ "D",
                                          behavior_punish_lag == 1 ~ "P"))
data1_cc = na.omit(data1b)
dim(data1_cc)
```

In general, the outcome for these models is the choice of punishing ("P") behavior vs. not choosing P.

### Model 1: Including both log behavior time and lag behavior time

```{r}
m1 = glmer(behavior_punish ~ showScore + age + gender + behavior_coop_lag + local_rate_coop_lag + behavior_punish_lag + local_rate_punish_lag + cPayoffS_lag + degree_lag + happ_lag + log_behaviorTime + log_behaviorTime_lag + factor(round) + (1|game) + (1|superid), data = data1_cc, family = binomial, nAGQ=0, control = glmerControl(optimizer = c("bobyqa"), optCtrl=list(maxfun=2e5), calc.derivs=FALSE))

se = sqrt(diag(vcov(m1)))
# table of estimates with 95% CI
tab_m1 = cbind(Est = fixef(m1), LL = fixef(m1) - 1.96 * se, UL = fixef(m1) + 1.96 * se)
round(exp(tab_m1), digits = 3)[1:13,]
```

### Model 2: Only including log behavior time

```{r}
m2 = glmer(behavior_punish ~ showScore + age + gender + behavior_coop_lag + local_rate_coop_lag + behavior_punish_lag + local_rate_punish_lag + cPayoffS_lag + degree_lag + happ_lag + log_behaviorTime  + factor(round) + (1|game) + (1|superid), data = data1_cc, family = binomial, nAGQ=0, control = glmerControl(optimizer = c("bobyqa"), optCtrl=list(maxfun=2e5), calc.derivs=FALSE))

se = sqrt(diag(vcov(m2)))
# table of estimates with 95% CI
tab_m2 = cbind(Est = fixef(m2), LL = fixef(m2) - 1.96 * se, UL = fixef(m2) + 1.96 * se)
round(exp(tab_m2), digits = 3)[1:12,]
```

### Model 3: Ignoring behavior time

```{r}
m3 = glmer(behavior_punish ~ showScore + age + gender + behavior_coop_lag + local_rate_coop_lag + behavior_punish_lag + local_rate_punish_lag + cPayoffS_lag + degree_lag + happ_lag+ factor(round) + (1|game) + (1|superid), data = data1_cc, family = binomial, nAGQ=0, control = glmerControl(optimizer = c("bobyqa"), optCtrl=list(maxfun=2e5), calc.derivs=FALSE))
se = sqrt(diag(vcov(m3)))
# table of estimates with 95% CI
tab_m3 = cbind(Est = fixef(m3), LL = fixef(m3) - 1.96 * se, UL = fixef(m3) + 1.96 * se)
round(exp(tab_m3), digits = 3)[1:11,]
```

### Model 3b: Treating local punish rate from the previous round as categorical

This will let us see the inflection point of the degree of local punish rate.

```{r}
data1_cc$local_rate_punish_cat = case_when(data1_cc$local_rate_punish_lag == 0 ~ 0,
                                          data1_cc$local_rate_punish_lag > 0 & data1_cc$local_rate_punish_lag <= 0.15 ~ 1,
                                          data1_cc$local_rate_punish_lag > 0.15 ~ 2)

m3_cat = glmer(behavior_punish ~ showScore + age + gender + behavior_coop_lag + local_rate_coop_lag + behavior_punish_lag + factor(local_rate_punish_cat) +  cPayoffS_lag + degree_lag + happ_lag + factor(round) + (1|game) + (1|superid), data = data1_cc, family = binomial, nAGQ=0, control = glmerControl(optimizer = c("bobyqa"), optCtrl=list(maxfun=2e5), calc.derivs=FALSE))
se = sqrt(diag(vcov(m3_cat)))
# table of estimates with 95% CI
tab_m3cat = cbind(Est = fixef(m3_cat), LL = fixef(m3_cat) - 1.96 * se, UL = fixef(m3_cat) + 1.96 * se)
round(exp(tab_m3cat), digits = 3)[1:12,]
```
 
### Model 3c: Adding additional categories, treating local cooperation rate from the previous round as categorical
    
Try 4 categories (0-24%, 25-49%, 50-74%, 75-100%) for cooperation to test for dose response.
    
```{r}
data1_cc$local_rate_punish_cat4 = case_when(data1_cc$local_rate_punish_lag >=0 & data1_cc$local_rate_punish_lag < 0.24 ~ 0,
                                            data1_cc$local_rate_punish_lag >=0.25 & data1_cc$local_rate_punish_lag < 0.49 ~ 1,
                                            data1_cc$local_rate_punish_lag >=0.5 & data1_cc$local_rate_punish_lag < 0.74 ~ 2,
                                            data1_cc$local_rate_punish_lag >=0.75 & data1_cc$local_rate_punish_lag ~ 3)

data1_cc$local_rate_coop_cat4 = case_when(data1_cc$local_rate_coop_lag >=0 & data1_cc$local_rate_coop_lag < 0.24 ~ 0,
                                            data1_cc$local_rate_coop_lag >=0.25 & data1_cc$local_rate_coop_lag < 0.49 ~ 1,
                                            data1_cc$local_rate_coop_lag >=0.5 & data1_cc$local_rate_coop_lag < 0.74 ~ 2,
                                            data1_cc$local_rate_coop_lag >=0.75 & data1_cc$local_rate_coop_lag ~ 3)

round(addmargins(prop.table(xtabs(~local_rate_coop_cat4 + behavior_punish, data1_cc))), digits = 3)

round(addmargins(prop.table(xtabs(~local_rate_coop_cat4 + behavior_punish, data1_cc), margin = 1), margin = 2), digits = 3)

m3_coop_cat4 = glmer(behavior_punish ~ showScore + age + gender + behavior_coop_lag + factor(local_rate_coop_cat4) + behavior_punish_lag + local_rate_punish_lag  + cPayoffS_lag + degree_lag + happ_lag + factor(round) + (1|game) + (1|superid), data = data1_cc, family = binomial, nAGQ=0, control = glmerControl(optimizer = c("bobyqa"), optCtrl=list(maxfun=2e5), calc.derivs=FALSE))

se = sqrt(diag(vcov(m3_coop_cat4)))
# table of estimates with 95% CI
tab_m3_coop_cat4 = cbind(Est = fixef(m3_coop_cat4), LL = fixef(m3_coop_cat4) - 1.96 * se, UL = fixef(m3_coop_cat4) + 1.96 * se)
round(exp(tab_m3_coop_cat4), digits = 3)[1:12,]
```

```{r}
m3.1_cat = glmer(behavior_punish ~ showScore + age + gender + behavior_coop_lag + local_rate_coop_lag + behavior_punish_lag + factor(local_rate_punish_cat) + cPayoffS_lag + degree_lag + happ_lag + log_behaviorTime + factor(round) + (1|game) + (1|superid), data = data1_cc, family = binomial, nAGQ=0, control = glmerControl(optimizer = c("bobyqa"), optCtrl=list(maxfun=2e5), calc.derivs=FALSE))
se = sqrt(diag(vcov(m3_cat)))
# table of estimates with 95% CI
tab_m3.1cat = cbind(Est = fixef(m3.1_cat), LL = fixef(m3.1_cat) - 1.96 * se, UL = fixef(m3.1_cat) + 1.96 * se)
round(exp(tab_m3.1cat), digits = 3)[1:13,] 
```

## 2. Does longer thinking time stop attacks?

Seems like more deliberation -> higher chance of attack. Less change in terms of rate of cooperation

- Contingency table for behavior time

```{r}
hist(data1$log_behaviorTime)
quantile(data1$log_behaviorTime, na.rm = T)
quantile(data1_cc$log_behaviorTime)
data1_cc$behaviorTime_cat = case_when(data1_cc$log_behaviorTime >= 3 & data1_cc$log_behaviorTime < 3.4 ~ 0,
                                      data1_cc$log_behaviorTime >= 3.4 & data1_cc$log_behaviorTime < 3.6 ~ 1,
                                      data1_cc$log_behaviorTime >= 3.6 & data1_cc$log_behaviorTime < 3.9 ~ 2,
                                      data1_cc$log_behaviorTime >= 3.9 ~ 3)

round(addmargins(prop.table(xtabs(~behaviorTime_cat + behavior_punish, data1_cc), margin = 1), margin = 2), digits = 3)
round(addmargins(prop.table(xtabs(~behaviorTime_cat + behavior_coop, data1_cc), margin = 1), margin = 2), digits = 3)

data1 %>%
  na.omit() %>%
  ggplot() +
  geom_boxplot(aes(x=behavior, y=log_behaviorTime)) +
  theme_minimal() +
  xlab("Behavior") +
  ylab("log Decision Time") +
  scale_x_discrete(labels = c("Cooperate", "Defect", "Punish"))
```

```{r}
summary(data1[is.na(data1$behaviorTime)==0 & data1$behaviorTime>=1000 & data1$behaviorTime<3000,]$behavior_coop)
#0.56
summary(data1[is.na(data1$behaviorTime)==0 & data1$behaviorTime>=3000 & data1$behaviorTime<5000,]$behavior_coop)
#0.49
summary(data1[is.na(data1$behaviorTime)==0 & data1$behaviorTime>=5000 & data1$behaviorTime<9000,]$behavior_coop)
#0.49
summary(data1[is.na(data1$behaviorTime)==0 & data1$behaviorTime>=9000 & data1$behaviorTime<1000000,]$behavior_coop)
#0.47

summary(data1[is.na(data1$behaviorTime)==0 & data1$behaviorTime>=1000 & data1$behaviorTime<3000,]$behavior_punish)
#0.03
summary(data1[is.na(data1$behaviorTime)==0 & data1$behaviorTime>=3000 & data1$behaviorTime<5000,]$behavior_punish)
#0.047
summary(data1[is.na(data1$behaviorTime)==0 & data1$behaviorTime>=5000 & data1$behaviorTime<9000,]$behavior_punish)
#0.069
summary(data1[is.na(data1$behaviorTime)==0 & data1$behaviorTime>=9000 & data1$behaviorTime<1000000,]$behavior_punish)
#0.079
```
