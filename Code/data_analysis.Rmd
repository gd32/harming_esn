---
title: "Evolution of Peace in Experimental Social Networks"
subtitle: "Data Analysis"
author: "George Dewey, Akihiro Nishi"
output: html_notebook
---

```{r setup, include="FALSE"}
knitr::opts_chunk$set(echo = T, message = F, warning = F, fig.align = "center", fig.height = 3, fig.width = 5, tidy.opts=list(width.cutoff=80), tidy=TRUE)
```

# Data Management + Cleaning

## Load packages

```{r}
library(reldist)
library(tidyverse)
library(Zelig)
library(lme4)
library(ggplot2)
library(lmerTest)
library(igraph) 
```

## Data Cleaning

Process the data in the same manner as Akihiro's initial analysis. 

```{r}
# Main data: mdata3
load("~/Documents/Projects/harming_esn/Data/mdata3.Rdata")
dim(mdata3) #10727 47
length(unique(mdata3$superid)) #745
```

### Set up convenience functions

```{r}
standardize = function(x) {
  mu = mean(x, na.rm = T)
  sd = sd(x, na.rm = T) 
  return ((x - mu)/sd)
}
```

### Data management

```{r}
#Checking id
harmdata = mdata3

# Renaming current rates
harmdata = harmdata %>% rename(local_rate_coop = cur_local_rate_coop, 
                    local_rate_defect = cur_local_rate_defect,
                    local_rate_punish = cur_local_rate_punish,
                    initial_defect = inital_defect)

# Create continuous happiness variable
harmdata$happ = ifelse(harmdata$satisfaction == "v_good", 2, 
                 ifelse(harmdata$satisfaction == "good", 1, 
                 ifelse(harmdata$satisfaction == "neutral", 0,
                 ifelse(harmdata$satisfaction == "bad", -1, 
                 ifelse(harmdata$satisfaction == "v_bad", -2, NA)))))

# Create positive wealth variable
harmdata$PosWealth = ifelse(harmdata$cumulativePayoff >= 0, 
                            harmdata$cumulativePayoff, 0)

# Create categorical WealthLevel (5 levels)
harmdata = harmdata %>%
  mutate(WealthLevel = case_when(cPayoffS < -1.5 ~ "Poorest",
                                 cPayoffS >= -1.5 & cPayoffS < -0.5  ~ "Poorer",
                                 cPayoffS >= -0.5 & cPayoffS < 0.5  ~ "Middle",
                                 cPayoffS >= 0.5 & cPayoffS < 1.5  ~ "Richer",
                                 cPayoffS >= 1.5  ~ "Richest"))

# Create wealth visibility
harmdata$showScore = ifelse(harmdata$showScore=="true",1,0)

###Renaming game ID as well (1XX for Happ, 2XX for Harm)
# harmdata$game = 200 + harmdata$game

###making the variable names the same over the two data
harmdata = harmdata[,!(names(harmdata) == "gameNumber")]

#Other variables
harmdata$age = as.numeric(unlist(harmdata$age))
harmdata$gender = as.character(unlist(harmdata$gender))
harmdata$ipAddress = as.character(unlist(harmdata$ipAddress))

# Convert IPaddress to country
library(rgeolocate)
file = system.file("extdata","GeoLite2-Country.mmdb", package = "rgeolocate")
ipCountries = maxmind(harmdata$ipAddress, file, "country_name")
harmdata$country = ipCountries$country_name

`%notin%` <- Negate(`%in%`)

harmdata = harmdata %>% 
  mutate(country_3cat = factor(case_when(country == "United States" ~ "US",
                                         country == "India" ~ "India",
                                         country %notin% c("United States", "India") ~ "Other"),
                               levels = c("US", "India", "Other")))
              
# Making data0 - base dataset for regression
names(harmdata)

data0 = harmdata %>% dplyr::select(game, superid, round, age, gender, 
                                   country_3cat, showScore, initial_score, 
                                   payoff, cumulativePayoff, cPayoffS, 
                                   WealthLevel, behavior_coop, behavior_defect, 
                                   behavior_punish, local_rate_coop, 
                                   local_rate_defect, local_rate_punish, happ, 
                                   behaviorTime, degree, e_degree, initial_coop,
                                   initial_defect, initial_punish)

#Making lag data
data_lag = data0 %>% dplyr::select(superid, round, initial_score, payoff, cumulativePayoff, cPayoffS, WealthLevel, behavior_coop, local_rate_coop, behavior_defect, local_rate_defect, behavior_punish, local_rate_punish, degree, happ, behaviorTime)

names(data_lag)[-c(1,2)] = paste0(names(data_lag)[-c(1,2)],"_lag")
data_lag$round = data_lag$round + 1

#merge
data1 = merge(x=data0,y=data_lag,all.x=T,all.y=F,by=c("superid","round"))

data1$log_behaviorTime = log10(data1$behaviorTime)
data1$log_behaviorTime_lag = log10(data1$behaviorTime_lag)
```

## Making the conflict variables

Conflict defined as:

Harming, dichotomous to costly punishment + non-punishing harming (everything else = non-justifiable harming?)

Criteria for costly punishment: cooperation at a prior round x the local cooperation rate at a prior round of <50% [note: downtrend but not 50% yet <- too early to justify? = preventive costly punishment?]

want to identify decision shifts + characterize them based on rate of cooperation. 
- Costly punishment: from c -> p based on local_rate_coop <50%
    - can be a gradient for this (i.e. 75->51%, etc.)

Costly punishment is like a last-resort shock to wake the defecting others as a majority up and changes their behavior to cooperation (the defection rate needs to be >50% per rule). 

Peace = no harming in the round (very common?)

Evolution of peace = no harming over the recent and current 5 rounds? (common as well?)

[We can check later if the result with harming is the same as that with costly punishment only and that with non-justifiable harming only]

```{r}
names(data1)

# Looking at behavior change from coop -> not coop
coop_to_not_coop = data1 %>% 
  group_by(game, superid) %>% 
  select(superid, game, round, behavior_coop, behavior_defect, behavior_punish, 
         behavior_coop_lag, behavior_defect_lag, behavior_punish_lag,
         local_rate_coop, local_rate_defect, local_rate_punish,
         local_rate_coop_lag, local_rate_defect_lag, local_rate_punish_lag,
         initial_coop, initial_defect, initial_punish, log_behaviorTime_lag) %>%
  filter(round != 0, behavior_coop != 1, behavior_coop_lag == 1) 

# Confirm that repetition and change differ in time
data2 = data1 %>% 
  group_by(game, superid) %>% 
  select(superid, game, round, behavior_coop, behavior_defect, behavior_punish, 
         behavior_coop_lag, behavior_defect_lag, behavior_punish_lag,
         local_rate_coop, local_rate_defect, local_rate_punish,
         local_rate_coop_lag, local_rate_defect_lag, local_rate_punish_lag,
         initial_coop, initial_defect, initial_punish, log_behaviorTime_lag) %>%
  mutate(behavior = case_when(behavior_coop == 1 ~ "C",
                              behavior_defect == 1 ~ "D",
                              behavior_punish == 1 ~ "P"),
         behavior_lag = case_when(behavior_coop_lag == 1 ~ "C",
                                  behavior_defect_lag == 1 ~ "D",
                                  behavior_punish_lag == 1 ~ "P"),
         repetition = ifelse(behavior == behavior_lag, 1, 0))

# Yes, the mean time for repeated behavior is shorter
data2 %>% 
  na.omit() %>%
  ggplot() + 
  geom_boxplot(aes(x=factor(repetition, levels = c(1, 0)), 
                   y = log_behaviorTime_lag))
rep_times = data2 %>% na.omit() %>% 
  filter(repetition == 1) %>% pull(log_behaviorTime_lag)
diff_times = data2 %>% na.omit() %>% 
  filter(repetition == 0) %>% pull(log_behaviorTime_lag)
t.test(rep_times, diff_times) # confirmed
```

```{r}
# Is it different for C-C, D-D, P-P?
data2 %>% 
  mutate(rep_cats = case_when(behavior == "C" & behavior_lag == "C" ~ "C-C",
                              behavior == "D" & behavior_lag == "D" ~ "D-D",
                              behavior == "P" & behavior_lag == "P" ~ "P-P")) %>% 
  na.omit() %>% 
  ggplot() + 
  geom_boxplot(aes(x = factor(rep_cats, levels = c("C-C", "D-D", "P-P")), 
                   y = log_behaviorTime_lag))
# the median punish time is a bit longer, but not by much - confirms repetition
# is the fastest/easiest regardless of type
```
```{r}
# Are there differences for the different combinations? CD CP DC DP PC PD
data2 = data2 %>% mutate(diff_cats = case_when(behavior == "C" & behavior_lag == "D" ~ "CD",
                                       behavior == "C" & behavior_lag == "P" ~ "CP",
                                       behavior == "D" & behavior_lag == "C" ~ "DC",
                                       behavior == "D" & behavior_lag == "P" ~ "DP",
                                       behavior == "P" & behavior_lag == "C" ~ "PC",
                                       behavior == "P" & behavior_lag == "D" ~ "PD"))

data2 %>% 
  na.omit() %>%
  ggplot() +
  geom_boxplot(aes(x=factor(diff_cats), y = log_behaviorTime_lag)) 
# Going back to cooperation is faster
```

```{r}  
# C -> P
grouped_means_c_to_p = coop_to_not_coop %>% 
  filter(behavior_punish == 1) %>% 
  summarize(mean_prev_coop_rate = mean(local_rate_coop_lag),
            mean_prev_def_rate = mean(local_rate_defect_lag),
            mean_prev_punish_rate = mean(local_rate_punish_lag),
            mean_prev_behavior_time = mean(log_behaviorTime_lag))

grouped_means_c_to_p %>% filter(mean_prev_punish_rate == 1)

# Group means
grouped_means_c_to_p %>% 
  filter(mean_prev_punish_rate != 0, mean_prev_punish_rate != 1) %>%
  ggplot() +
  geom_point(aes(x=mean_prev_punish_rate, 
                 y = mean_prev_behavior_time, 
                 color = factor(superid))) +
  geom_smooth(aes(x=mean_prev_punish_rate,
                  y=mean_prev_behavior_time),
              method = "loess", formula = y ~ x)

# View instances of costly punishment

coop_to_not_coop %>% 
  filter(behavior_punish == 1, local_rate_coop_lag < 0.5) %>% 
  select(superid, game, round, local_rate_coop_lag, local_rate_punish_lag,
         local_rate_coop, local_rate_punish) %>% 
  ggplot() + 
  geom_point(aes(x=local_rate_punish_lag, local_rate_punish, 
                 color = factor(superid))) 

# Filter by potential for costly punishment
coop_to_not_coop %>% ungroup() %>%
  filter(local_rate_coop_lag < 0.5) %>%
  summarize(n_defects = sum(behavior_defect),
            n_punish= sum(behavior_punish))
# 297 defects, 104 punishes

c1 = coop_to_not_coop %>% 
  filter(local_rate_coop_lag < 0.5) %>%
  mutate(behavior = case_when(behavior_defect == 1 ~ "D",
                              behavior_punish == 1 ~ "P")) %>%
  select(superid, game, round, behavior, local_rate_coop_lag, local_rate_defect_lag,
         local_rate_punish_lag, initial_coop, initial_defect, initial_punish,
         log_behaviorTime_lag) # 4 missing - ignore

c1_clean = na.omit(c1)

c1_clean %>%
  ggplot() + geom_boxplot(aes(x = behavior, y = log_behaviorTime_lag))

# Can we distinguish between costly and non-costly punishment?
coop_to_not_coop %>% 
  filter(behavior_punish == 1) %>% 
  ggplot() + 
  geom_point(aes(x=local_rate_coop_lag, y=log_behaviorTime_lag)) +
  geom_smooth(aes(x=local_rate_coop_lag, y=log_behaviorTime_lag),
              method = "loess", formula = y ~ x)

coop_to_not_coop %>% 
  filter(behavior_punish == 1) %>%
  ggplot()+
  geom_histogram(aes(x=local_rate_coop_lag), bins = 10) +
  scale_x_continuous(breaks = c(seq(0, 1, by = 0.1))) # Maybe 3cat - 0-0.25, 0.25-0.5, 0.5+
  # or just 2cat - 0-0.5, 0.5+

coop_to_not_coop = coop_to_not_coop %>%
  mutate(behavior = case_when(behavior_defect == 1 ~ "D",
                              behavior_punish == 1 ~ "P"),
         noncoop_env = ifelse(local_rate_coop_lag < 0.5, 1, 0),
         noncoop_env_3cat = case_when(local_rate_coop_lag >= 0.5 ~ 0,
                                      local_rate_coop_lag >= 0.25 & local_rate_coop_lag < 0.5 ~ 1,
                                      local_rate_coop_lag >= 0 & local_rate_coop_lag <0.25 ~ 2))
  
xtabs(~noncoop_env + behavior, data = coop_to_not_coop)
xtabs(~noncoop_env_3cat + behavior, data = coop_to_not_coop)
xtabs(~behavior, data=coop_to_not_coop)

coop_to_p = coop_to_not_coop %>% 
  filter(behavior == "P")

xtabs(~behavior + noncoop_env_3cat, data = coop_to_p)

coop_to_p %>% na.omit() %>%
  ggplot() +
  geom_boxplot(aes(x=factor(noncoop_env, levels = c(0, 1)), y=log_behaviorTime_lag)) +
  scale_x_discrete(labels = c("Cooperative Environment", "Non-cooperative Environment"))

coop_times = coop_to_p %>% filter(noncoop_env == 0) %>% pull(log_behaviorTime_lag)
non_coop_times = coop_to_p %>% filter(noncoop_env == 1) %>% pull(log_behaviorTime_lag)
t.test(coop_times, non_coop_times, var.equal = F) # no different in time based on environment
```

## Answering questions about the games

How many times does peace occur (i.e. in one round, no harming is chosen)?

```{r}

```

## Analysis

### 1. What are the characteristics of people who chose to attack (=performing costly sanction)? (social demographic emotional) (who include attack in their behavior strategy?) We can evaluate this question using two approaches: 

#### a) Using the binary attack indicator (so factors influencing specific individual choices) 
    
```{r}
names(data1)
# Make the categorical behavior variable
data1b = data1 %>% mutate(behavior = case_when(behavior_coop == 1 ~ "C",
                                      behavior_defect == 1 ~ "D",
                                      behavior_punish == 1 ~ "P"),
                 behavior_lag = case_when(behavior_coop_lag == 1 ~ "C",
                                          behavior_defect_lag ==1 ~ "D",
                                          behavior_punish_lag == 1 ~ "P"))
data1_cc = na.omit(data1b)
dim(data1_cc)
```

## Binary outcomes

```{r}
m1 = glmer(behavior_punish ~ showScore + age + gender + behavior_coop_lag + local_rate_coop_lag + behavior_punish_lag + local_rate_punish_lag + cPayoffS_lag + degree_lag + happ_lag + log_behaviorTime + log_behaviorTime_lag + factor(round) + (1|game) + (1|superid), data = data1_cc, family = binomial, nAGQ=0, control = glmerControl(optimizer = c("bobyqa"), optCtrl=list(maxfun=2e5), calc.derivs=FALSE))

se = sqrt(diag(vcov(m1)))
# table of estimates with 95% CI
tab_m1 = cbind(Est = fixef(m1), LL = fixef(m1) - 1.96 * se, UL = fixef(m1) + 1.96 * se)
round(exp(tab_m1), digits = 3)[1:13,]
```

```{r}
m2 = glmer(behavior_punish ~ showScore + age + gender + behavior_coop_lag + local_rate_coop_lag + behavior_punish_lag + local_rate_punish_lag + cPayoffS_lag + degree_lag + happ_lag + log_behaviorTime  + factor(round) + (1|game) + (1|superid), data = data1_cc, family = binomial, nAGQ=0, control = glmerControl(optimizer = c("bobyqa"), optCtrl=list(maxfun=2e5), calc.derivs=FALSE))
se = sqrt(diag(vcov(m2)))
# table of estimates with 95% CI
tab_m2 = cbind(Est = fixef(m2), LL = fixef(m2) - 1.96 * se, UL = fixef(m2) + 1.96 * se)
round(exp(tab_m2), digits = 3)[1:12,]
```

```{r}
m3 = glmer(behavior_punish ~ showScore + age + gender + behavior_coop_lag + local_rate_coop_lag + behavior_punish_lag + local_rate_punish_lag + cPayoffS_lag + degree_lag + happ_lag+ factor(round) + (1|game) + (1|superid), data = data1_cc, family = binomial, nAGQ=0, control = glmerControl(optimizer = c("bobyqa"), optCtrl=list(maxfun=2e5), calc.derivs=FALSE))
se = sqrt(diag(vcov(m3)))
# table of estimates with 95% CI
tab_m3 = cbind(Est = fixef(m3), LL = fixef(m3) - 1.96 * se, UL = fixef(m3) + 1.96 * se)
round(exp(tab_m3), digits = 3)[1:11,]
```
#### Trying model 3 with categorical rate

```{r}
data1_cc$local_rate_punish_cat = case_when(data1_cc$local_rate_punish_lag == 0 ~ 0,
                                          data1_cc$local_rate_punish_lag > 0 & data1_cc$local_rate_punish_lag <= 0.15 ~ 1,
                                          data1_cc$local_rate_punish_lag > 0.15 ~ 2)
xtabs(~behavior_punish + local_rate_punish_cat, data1_cc)

m3_cat = glmer(behavior_punish ~ showScore + age + gender + behavior_coop_lag + local_rate_coop_lag + behavior_punish_lag + factor(local_rate_punish_cat) +  cPayoffS_lag + degree_lag + happ_lag + factor(round) + (1|game) + (1|superid), data = data1_cc, family = binomial, nAGQ=0, control = glmerControl(optimizer = c("bobyqa"), optCtrl=list(maxfun=2e5), calc.derivs=FALSE))
se = sqrt(diag(vcov(m3_cat)))
# table of estimates with 95% CI
tab_m3cat = cbind(Est = fixef(m3_cat), LL = fixef(m3_cat) - 1.96 * se, UL = fixef(m3_cat) + 1.96 * se)
round(exp(tab_m3cat), digits = 3)[1:12,]
```
 
#### 1b) Add more categories to category 2?
    
Try 4 categories (0-24%, 25-49%, 50-74%, 75-100%) for cooperation to test for dose response.
    
```{r}
data1_cc$local_rate_punish_cat4 = case_when(data1_cc$local_rate_punish_lag >=0 & data1_cc$local_rate_punish_lag < 0.24 ~ 0,
                                            data1_cc$local_rate_punish_lag >=0.25 & data1_cc$local_rate_punish_lag < 0.49 ~ 1,
                                            data1_cc$local_rate_punish_lag >=0.5 & data1_cc$local_rate_punish_lag < 0.74 ~ 2,
                                            data1_cc$local_rate_punish_lag >=0.75 & data1_cc$local_rate_punish_lag ~ 3)

data1_cc$local_rate_coop_cat4 = case_when(data1_cc$local_rate_coop_lag >=0 & data1_cc$local_rate_coop_lag < 0.24 ~ 0,
                                            data1_cc$local_rate_coop_lag >=0.25 & data1_cc$local_rate_coop_lag < 0.49 ~ 1,
                                            data1_cc$local_rate_coop_lag >=0.5 & data1_cc$local_rate_coop_lag < 0.74 ~ 2,
                                            data1_cc$local_rate_coop_lag >=0.75 & data1_cc$local_rate_coop_lag ~ 3)

round(addmargins(prop.table(xtabs(~local_rate_coop_cat4 + behavior_punish, data1_cc))), digits = 3)

round(addmargins(prop.table(xtabs(~local_rate_coop_cat4 + behavior_punish, data1_cc), margin = 1), margin = 2), digits = 3)

m3_coop_cat4 = glmer(behavior_punish ~ showScore + age + gender + behavior_coop_lag + factor(local_rate_coop_cat4) + behavior_punish_lag + local_rate_punish_lag  + cPayoffS_lag + degree_lag + happ_lag + factor(round) + (1|game) + (1|superid), data = data1_cc, family = binomial, nAGQ=0, control = glmerControl(optimizer = c("bobyqa"), optCtrl=list(maxfun=2e5), calc.derivs=FALSE))

se = sqrt(diag(vcov(m3_coop_cat4)))
# table of estimates with 95% CI
tab_m3_coop_cat4 = cbind(Est = fixef(m3_coop_cat4), LL = fixef(m3_coop_cat4) - 1.96 * se, UL = fixef(m3_coop_cat4) + 1.96 * se)
round(exp(tab_m3_coop_cat4), digits = 3)[1:12,]
```

```{r}
m3.1_cat = glmer(behavior_punish ~ showScore + age + gender + behavior_coop_lag + local_rate_coop_lag + behavior_punish_lag + factor(local_rate_punish_cat) + cPayoffS_lag + degree_lag + happ_lag + log_behaviorTime + factor(round) + (1|game) + (1|superid), data = data1_cc, family = binomial, nAGQ=0, control = glmerControl(optimizer = c("bobyqa"), optCtrl=list(maxfun=2e5), calc.derivs=FALSE))
se = sqrt(diag(vcov(m3_cat)))
# table of estimates with 95% CI
tab_m3.1cat = cbind(Est = fixef(m3.1_cat), LL = fixef(m3.1_cat) - 1.96 * se, UL = fixef(m3.1_cat) + 1.96 * se)
round(exp(tab_m3.1cat), digits = 3)[1:13,] 
```

#### 1c) Evaluating characteristics of ever attackers
    
```{r}
ever_attackers = unique(harmdata %>% group_by(superid) %>% filter(behavior_punish == 1) %>% pull(superid))
ever_cooperator = unique(harmdata %>% group_by(superid) %>% filter(behavior_coop == 1) %>% pull(superid))

harmdata$ever_attacker = ifelse(harmdata$superid %in% ever_attackers, 1, 0)
harmdata$ever_cooperator = ifelse(harmdata$superid %in% ever_cooperator, 1, 0)

# Convert IPaddress to country
library(rgeolocate)
file = system.file("extdata","GeoLite2-Country.mmdb", package = "rgeolocate")
ipCountries = maxmind(harmdata$ipAddress, file, "country_name")
harmdata$country = ipCountries$country_name
table(harmdata$country) #messy

`%notin%` <- Negate(`%in%`)

harmdata = harmdata %>% mutate(country_3cat = case_when(country == "United States" ~ "US",
                                                        country == "India" ~ "India",
                                                        country %notin% c("United States", "India") ~ "Other"))

harmdata = harmdata %>% mutate(country_3cat = factor(country_3cat, levels = c("US", "India", "Other")))

harmdata_clean = na.omit(harmdata)

# use round 2 + take non-varying variables
# check non-varying if usable - show other sociodemographic variables
# IP address - country of origin?

harmdata_no_rep = harmdata %>% filter(round == 2)

# add PANAS variables
m4 = glmer(ever_attacker ~ showScore + age + gender + country_3cat + (1|game), data = harmdata_no_rep, family = binomial, nAGQ=0, control = glmerControl(optimizer = c("bobyqa"), optCtrl=list(maxfun=2e5), calc.derivs=FALSE))

se = sqrt(diag(vcov(m4)))
# table of estimates with 95% CI
tab_m4 = cbind(Est = fixef(m4), LL = fixef(m4) - 1.96 * se, UL = fixef(m4) + 1.96 * se)
round(exp(tab_m4), digits = 3) #Indian users more likely to choose punish?

xtabs(~country_3cat + ever_attacker, harmdata_no_rep) # maybe - have less Indian users + more punishers overall
```

**note**:
Do naturally aggressive people learn to be less aggressive over games played with less aggressive players?

1c) Looking at trends of harming over every round

To see a global trend of the rate of harming over 15 rounds per each session, could you make a figure in which x axis is round, y axis is the rate of harming, and 50 linegraphs representing 50 sessions?

```{r, fig.height =3, fig.width =5}
data0_cc = na.omit(data0)

data0_sum = data0_cc %>% group_by(game, round) %>% summarize(mean_punish_rate = mean(local_rate_punish)) 

library(viridis)

# Messy with all 50
data0_sum %>% ggplot() + 
  geom_line(aes(x= round, y = mean_punish_rate, group = factor(game), color = factor(game))) +
  scale_x_continuous(breaks = c(1, 5, 10, 15),
                   labels = c(1, 5, 10, 15)) +
  scale_color_viridis(discrete = T) +
  xlab("Round")+
  ylab("Mean Local Punish Rate") +
  theme(legend.position = c("none"))
```
```{r}
data0_sum %>% filter(mean_punish_rate > 0.3)
```

```{r}
# Try using smooth curve
data0_sum %>% ggplot() + 
  geom_smooth(aes(x= round, y = mean_punish_rate, group = factor(game), color = factor(game)),
              method = "loess", se = FALSE) +
  scale_x_continuous(breaks = c(1, 5, 10, 15),
                   labels = c(1, 5, 10, 15)) +
  scale_color_viridis(discrete = T) +
  xlab("Round")+
  ylab("Mean Local Punish Rate") +
  theme(legend.position = c("none"))
```
```{r}
#Clearer with groups of 25
# Games 1-25
data0_sum %>% filter(game %in% 1:25) %>% ggplot() + 
  geom_smooth(aes(x= round, y = mean_punish_rate, group = factor(game), color = factor(game)),
              method = "loess", formula = y ~ x, se = FALSE) +
  scale_x_continuous(breaks = c(1, 5, 10, 15),
                   labels = c(1, 5, 10, 15)) +
  scale_color_viridis(discrete = TRUE) +
  xlab("Round")+
  ylab("Mean Local Punish Rate")+
  theme(legend.position = c("none"))
```

```{r}
# Games 26-50
data0_sum %>% filter(game %in% 26:50) %>% ggplot() + 
  geom_smooth(aes(x= round, y = mean_punish_rate, group = factor(game), color = factor(game)),
              method = "loess", formula = y ~ x, se = FALSE) +
  scale_x_continuous(breaks = c(1, 5, 10, 15),
                   labels = c(1, 5, 10, 15)) +
  scale_color_viridis(discrete = T) +
  xlab("Round")+
  ylab("Mean Local Punish Rate") +
  theme(legend.position = c("none"))
```


#### 1d) Multinomial outcomes

First, compare P vs. C+D (should be the same as the binary ones)

```{r}
data1_cc_1d = data1_cc %>% mutate(behavior_punish_binary = ifelse(behavior == "P", 1, 0))

m1_1d = glmer(behavior_punish ~ showScore + age + gender + behavior_coop_lag + local_rate_coop_lag + behavior_punish_lag + local_rate_punish_lag + cPayoffS_lag + degree_lag + happ_lag + log_behaviorTime + log_behaviorTime_lag + factor(round) + (1|game) + (1|superid), data = data1_cc_1d, family = binomial, nAGQ=0, control = glmerControl(optimizer = c("bobyqa"), optCtrl=list(maxfun=2e5), calc.derivs=FALSE))

se = sqrt(diag(vcov(m1_1d)))
# table of estimates with 95% CI
tab_m1_1d = cbind(Est = fixef(m1_1d), LL = fixef(m1_1d) - 1.96 * se, UL = fixef(m1_1d) + 1.96 * se)
round(exp(tab_m1_1d), digits = 3)[1:13,] # confirmed to be same
```
Now use multinomial behavior as the outcome (without and with time)

```{r}
library(mgcv)


data1_cc_1d = data1_cc_1d %>% mutate(behavior = factor(behavior, levels = c("C", "D", "P")),
                                     behavior_numeric = case_when(behavior == "C" ~ 0,
                                                                  behavior == "D" ~ 1,
                                                                  behavior == "P" ~ 2))

# Multinomial with random effects
terms_list = list(behavior_numeric ~ showScore + age + gender + factor(behavior_lag) + local_rate_coop_lag + local_rate_punish_lag + cPayoffS_lag + degree_lag + happ_lag + factor(round) + s(game, bs = "re") + s(superid, bs = "re"), ~ showScore + age + gender + factor(behavior_lag) + local_rate_coop_lag + local_rate_punish_lag + cPayoffS_lag + degree_lag + happ_lag + factor(round) + s(game, bs = "re") + s(superid, bs = "re"),  ~ showScore + age + gender + factor(behavior_lag) + local_rate_coop_lag + local_rate_punish_lag + cPayoffS_lag + degree_lag + happ_lag + factor(round) + s(game, bs = "re") + s(superid, bs = "re"), ~ showScore + age + gender + factor(behavior_lag) + local_rate_coop_lag + local_rate_punish_lag + cPayoffS_lag + degree_lag + happ_lag + factor(round) + s(game, bs = "re") + s(superid, bs = "re"), ~ showScore + age + gender + factor(behavior_lag) + local_rate_coop_lag + local_rate_punish_lag + cPayoffS_lag + degree_lag + happ_lag + factor(round) + s(game, bs = "re") + s(superid, bs = "re"), ~ showScore + age + gender + factor(behavior_lag) + local_rate_coop_lag + local_rate_punish_lag + cPayoffS_lag + degree_lag + happ_lag + factor(round) + s(game, bs = "re") + s(superid, bs = "re"), ~ showScore + age + gender + factor(behavior_lag) + local_rate_coop_lag + local_rate_punish_lag + cPayoffS_lag + degree_lag + happ_lag + factor(round) + s(game, bs = "re") + s(superid, bs = "re"), ~ showScore + age + gender + factor(behavior_lag) + local_rate_coop_lag + local_rate_punish_lag + cPayoffS_lag + degree_lag + happ_lag + factor(round) + s(game, bs = "re") + s(superid, bs = "re"),~ showScore + age + gender + factor(behavior_lag) + local_rate_coop_lag + local_rate_punish_lag + cPayoffS_lag + degree_lag + happ_lag + factor(round) + s(game, bs = "re") + s(superid, bs = "re"),~ showScore + age + gender + factor(behavior_lag) + local_rate_coop_lag + local_rate_punish_lag + cPayoffS_lag + degree_lag + happ_lag + factor(round) + s(game, bs = "re") + s(superid, bs = "re"),~ showScore + age + gender + factor(behavior_lag) + local_rate_coop_lag + local_rate_punish_lag + cPayoffS_lag + degree_lag + happ_lag + factor(round) + s(game, bs = "re") + s(superid, bs = "re"),~ showScore + age + gender + factor(behavior_lag) + local_rate_coop_lag + local_rate_punish_lag + cPayoffS_lag + degree_lag + happ_lag + factor(round) + s(game, bs = "re") + s(superid, bs = "re")) 

m2_1d = gam(terms_list, data = data1_cc_1d, family = multinom(K = 12))


# Without time
m2_1d = gam(models, data = data1_cc_1d, family = multinom(K = 2))

m2_1d = glmer(behavior ~ showScore + age + gender + factor(behavior_lag) + local_rate_coop_lag + local_rate_punish_lag + cPayoffS_lag + degree_lag + happ_lag + factor(round) + s(game, bs = "re") + s(superid, bs = "re"), data = data1_cc_1d, family = multinom(K = 3))

se = sqrt(diag(vcov(m2_1d)))
# table of estimates with 95% CI
tab_m2_1d = cbind(Est = fixef(m2_1d), LL = fixef(m2_1d) - 1.96 * se, UL = fixef(m2_1d) + 1.96 * se)
round(exp(tab_m2_1d), digits = 3)[1:11,] # confirmed to be same
```

### 2. Does longer thinking time stop attacks?

Seems like more deliberation -> higher chance of attack. Less change in terms of rate of cooperation

- Contingency table for behavior time

```{r}
hist(data1$log_behaviorTime)
quantile(data1$log_behaviorTime, na.rm = T)
quantile(data1_cc$log_behaviorTime)
data1_cc$behaviorTime_cat = case_when(data1_cc$log_behaviorTime >= 3 & data1_cc$log_behaviorTime < 3.4 ~ 0,
                                      data1_cc$log_behaviorTime >= 3.4 & data1_cc$log_behaviorTime < 3.6 ~ 1,
                                      data1_cc$log_behaviorTime >= 3.6 & data1_cc$log_behaviorTime < 3.9 ~ 2,
                                      data1_cc$log_behaviorTime >= 3.9 ~ 3)

round(addmargins(prop.table(xtabs(~behaviorTime_cat + behavior_punish, data1_cc), margin = 1), margin = 2), digits = 3)
round(addmargins(prop.table(xtabs(~behaviorTime_cat + behavior_coop, data1_cc), margin = 1), margin = 2), digits = 3)
```

```{r}
summary(data1[is.na(data1$behaviorTime)==0 & data1$behaviorTime>=1000 & data1$behaviorTime<3000,]$behavior_coop)
#0.56
summary(data1[is.na(data1$behaviorTime)==0 & data1$behaviorTime>=3000 & data1$behaviorTime<5000,]$behavior_coop)
#0.49
summary(data1[is.na(data1$behaviorTime)==0 & data1$behaviorTime>=5000 & data1$behaviorTime<9000,]$behavior_coop)
#0.49
summary(data1[is.na(data1$behaviorTime)==0 & data1$behaviorTime>=9000 & data1$behaviorTime<1000000,]$behavior_coop)
#0.47

summary(data1[is.na(data1$behaviorTime)==0 & data1$behaviorTime>=1000 & data1$behaviorTime<3000,]$behavior_punish)
#0.03
summary(data1[is.na(data1$behaviorTime)==0 & data1$behaviorTime>=3000 & data1$behaviorTime<5000,]$behavior_punish)
#0.047
summary(data1[is.na(data1$behaviorTime)==0 & data1$behaviorTime>=5000 & data1$behaviorTime<9000,]$behavior_punish)
#0.069
summary(data1[is.na(data1$behaviorTime)==0 & data1$behaviorTime>=9000 & data1$behaviorTime<1000000,]$behavior_punish)
#0.079
```

### 3. What factors stop consecutive attacks?

    a) Identify attack patterns - first, create a new dataset that characterizes behavior by each actor in consecutive rounds.
    
```{r}
# Want the unit to be paired values
# Basically want to combine the lag/cumulative values
# Group variables: superid, game
# Unit variables: round (should be round + round+1), behavior in consecutive rounds (i.e. behavior_lag + behavior?)
# Lag + behavior (current round) represents consecutive choices
# Other things: local rate/behavior time/cpayoffs? - want diffs or means/medians? 

data1_consecutive = data1_cc

# Create new data where one row = 2 consecutive choices
data1_consecutive = data1_consecutive %>% mutate(behavior = case_when(behavior_coop == 1 ~ "C",
                                                  behavior_defect == 1 ~ "D",
                                                  behavior_punish == 1 ~ "P"),
                             behavior_lag = case_when(behavior_coop_lag == 1 ~ "C",
                                                      behavior_defect_lag == 1 ~ "D",
                                                      behavior_punish_lag == 1 ~ "P"),
                             behavior_pair = paste0(behavior_lag, behavior), #pair is prev+current
                             round_pair = paste0(as.character(round-1), as.character(round)),
                             happ_diff = happ - happ_lag,
                             cPayoffS_diff = cPayoffS - cPayoffS_lag,
                             degree_diff = degree - degree_lag,
                             behaviorTime_diff = behaviorTime - behaviorTime_lag) %>%
                      dplyr::select(superid, behavior_pair, round_pair, age, gender, showScore, initial_score, happ_diff,
                                    cPayoffS_diff, degree_diff, behaviorTime_diff)

```

```{r}
#Try regression where outcome is behavior pair?
# Exclude round 0/1
# Maybe set CC to reference (most common pair)
`%notin%` <- Negate(`%in%`)
table(data1_consecutive$behavior_pair)
data1_cs_short = data1_consecutive %>% filter(round_pair %notin% c(-10, 01)) %>% 
  mutate(behavior_pair = factor(behavior_pair, levels = c("CC", "CD", "CP", "DD", "DC", "DP", "PC", "PD", "PP")),
         behavior_pair2 = case_when(behavior_pair %in% c("CC", "CD", "CP", "DD", "DC", "DP") ~ 0,
                                    behavior_pair == "PC" ~ 1,
                                    behavior_pair == "PD" ~ 2,
                                    behavior_pair == "PP" ~ 3))

```

```{r}
# Try multinomial regression
names(data1_cs_short)

library(nnet)
library(broom)

model5 = multinom(behavior_pair2 ~ age + gender + showScore + initial_score + happ_diff + cPayoffS_diff + degree_diff + behaviorTime_diff, data = data1_cs_short)
model5_result = tidy(model5, conf.int = T, conf.level = 0.95, exponentiate = TRUE) %>% dplyr::select(y.level, term, estimate, conf.low, conf.high)
model5_coefs = model5_result %>% dplyr::select(estimate, conf.low, conf.high)
model5_result2 = cbind(model5_result$y.level, model5_result$term, model5_coefs)
model5_result2

# model5 = glm(behavior_pair2 ~ age + gender + showScore + initial_score + happ_diff + cPayoffS_diff + degree_diff + behaviorTime_diff, family = "binomial", data = data1_cs_short)
# summary(model5)
```
```{r}
# Multilevel multinomial?
```

How to visualize this? Network visualization? 2D visual of progress showing each actor's strategy?

---

# Next steps for this

Add a lag 2 set of variables

Interaction between lag1 and lag2

---

## 2. Building a network representation of activity

```{r}
load("~/Documents/Projects/harming_esn/Data/harming_jsons/ldata4_0316X.Rdata") #ldata4
load("~/Documents/Projects/harming_esn/Data/ndata_individual.Rdata") #ndata1
```

```{r}
library(igraph)
library(tidygraph)
library(RColorBrewer)

# ndata1_r0 = ndata1 %>% filter(game == 1, round == 0) %>% relocate(id) %>% unnest()
ndata1_r1 = ndata1 %>% filter(game == 1, round == 1) %>% relocate(id)
ndata1_r2 = ndata1 %>% filter(game == 1, round == 2) %>% relocate(id) 
ndata1_r3 = ndata1 %>% filter(game == 1, round == 3) %>% relocate(id) 
ndata1_r4 = ndata1 %>% filter(game == 1, round == 4) %>% relocate(id) 
ndata1_r5 = ndata1 %>% filter(game == 1, round == 5) %>% relocate(id) 
ndata1_r6 = ndata1 %>% filter(game == 1, round == 6) %>% relocate(id) 
ndata1_r7 = ndata1 %>% filter(game == 1, round == 7) %>% relocate(id) 
ndata1_r8 = ndata1 %>% filter(game == 1, round == 8) %>% relocate(id) 
ndata1_r9 = ndata1 %>% filter(game == 1, round == 9) %>% relocate(id) 
ndata1_r10 = ndata1 %>% filter(game == 1, round == 10) %>% relocate(id) 
ndata1_r11 = ndata1 %>% filter(game == 1, round == 11) %>% relocate(id) 
ndata1_r12 = ndata1 %>% filter(game == 1, round == 12) %>% relocate(id) 
ndata1_r13 = ndata1 %>% filter(game == 1, round == 13) %>% relocate(id) 
ndata1_r14 = ndata1 %>% filter(game == 1, round == 14) %>% relocate(id) 
ndata1_r15 = ndata1 %>% filter(game == 1, round == 15) %>% relocate(id) 
```

```{r}
# For game 1
set.seed(123)
# game1_round0_edgelist = ldata4 %>% filter(game == 1, round == 0) %>% dplyr::select(id1, id2)
# g0 = graph_from_data_frame(game1_round0_edgelist, directed = T, vertices = ndata1_r0)
# pal = brewer.pal(length(unique(V(g0)$behavior)), "Set1") #Red = D, Blue = C, Green = P
# coords = layout.auto(g0)

game1_round1_edgelist = ldata4 %>% filter(game == 1, round == 1) %>% dplyr::select(id1, id2)
g1 = graph_from_data_frame(game1_round1_edgelist, directed = T, vertices = ndata1_r1)
pal = brewer.pal(length(unique(V(g1)$behavior)), "Set1") #Red = D, Blue = C, Green = P
coords = layout.auto(g1)

game1_round2_edgelist = ldata4 %>% filter(game == 1, round == 2) %>% dplyr::select(id1, id2)
g2 = graph_from_data_frame(game1_round2_edgelist, directed = T, vertices = ndata1_r2)

game1_round3_edgelist = ldata4 %>% filter(game == 1, round == 3) %>% dplyr::select(id1, id2)
g3 = graph_from_data_frame(game1_round3_edgelist, directed = T, vertices = ndata1_r3)

game1_round4_edgelist = ldata4 %>% filter(game == 1, round == 4) %>% dplyr::select(id1, id2)
g4 = graph_from_data_frame(game1_round4_edgelist, directed = T, vertices = ndata1_r4)

game1_round5_edgelist = ldata4 %>% filter(game == 1, round == 5) %>% dplyr::select(id1, id2)
g5 = graph_from_data_frame(game1_round5_edgelist, directed = T, vertices = ndata1_r5)

game1_round6_edgelist = ldata4 %>% filter(game == 1, round == 6) %>% dplyr::select(id1, id2)
g6 = graph_from_data_frame(game1_round6_edgelist, directed = T, vertices = ndata1_r6)

game1_round7_edgelist = ldata4 %>% filter(game == 1, round == 7) %>% dplyr::select(id1, id2)
g7 = graph_from_data_frame(game1_round7_edgelist, directed = T, vertices = ndata1_r7)

game1_round8_edgelist = ldata4 %>% filter(game == 1, round == 8) %>% dplyr::select(id1, id2)
g8 = graph_from_data_frame(game1_round8_edgelist, directed = T, vertices = ndata1_r8)

game1_round9_edgelist = ldata4 %>% filter(game == 1, round == 9) %>% dplyr::select(id1, id2)
g9 = graph_from_data_frame(game1_round9_edgelist, directed = T, vertices = ndata1_r9)

game1_round10_edgelist = ldata4 %>% filter(game == 1, round == 10) %>% dplyr::select(id1, id2)
g10 = graph_from_data_frame(game1_round10_edgelist, directed = T, vertices = ndata1_r10)

game1_round11_edgelist = ldata4 %>% filter(game == 1, round == 11) %>% dplyr::select(id1, id2)
g11 = graph_from_data_frame(game1_round11_edgelist, directed = T, vertices = ndata1_r11)

game1_round12_edgelist = ldata4 %>% filter(game == 1, round == 12) %>% dplyr::select(id1, id2)
g12 = graph_from_data_frame(game1_round12_edgelist, directed = T, vertices = ndata1_r12)

game1_round13_edgelist = ldata4 %>% filter(game == 1, round == 13) %>% dplyr::select(id1, id2)
g13 = graph_from_data_frame(game1_round13_edgelist, directed = T, vertices = ndata1_r13)

game1_round14_edgelist = ldata4 %>% filter(game == 1, round == 14) %>% dplyr::select(id1, id2)
g14 = graph_from_data_frame(game1_round14_edgelist, directed = T, vertices = ndata1_r14)

game1_round15_edgelist = ldata4 %>% filter(game == 1, round == 15) %>% dplyr::select(id1, id2)
g15 = graph_from_data_frame(game1_round15_edgelist, directed = T, vertices = ndata1_r15)

# Create animation
saveGIF({
  plot(g1, 
     layout = coords, 
     vertex.color = pal[as.numeric(factor(vertex_attr(g1, "behavior"), levels = c("D", "C", "P")))])
  plot(g2, 
     layout = coords, 
     vertex.color = pal[as.numeric(factor(vertex_attr(g2, "behavior"), levels = c("D", "C", "P")))])
  plot(g3, 
     layout = coords, 
     vertex.color = pal[as.numeric(factor(vertex_attr(g3, "behavior"), levels = c("D", "C", "P")))])
  plot(g4, 
     layout = coords, 
     vertex.color = pal[as.numeric(factor(vertex_attr(g4, "behavior"), levels = c("D", "C", "P")))])
  plot(g5, 
     layout = coords,  
     vertex.color = pal[as.numeric(factor(vertex_attr(g5, "behavior"), levels = c("D", "C", "P")))])
  plot(g6, 
     layout = coords,  
     vertex.color = pal[as.numeric(factor(vertex_attr(g6, "behavior"), levels = c("D", "C", "P")))])
  plot(g7, 
     layout = coords,  
     vertex.color = pal[as.numeric(factor(vertex_attr(g7, "behavior"), levels = c("D", "C", "P")))])
  plot(g8, 
     layout = coords,  
     vertex.color = pal[as.numeric(factor(vertex_attr(g8, "behavior"), levels = c("D", "C", "P")))]) 
  plot(g9, 
     layout = coords,  
     vertex.color = pal[as.numeric(factor(vertex_attr(g9, "behavior"), levels = c("D", "C", "P")))])
  plot(g10, 
     layout = coords,  
     vertex.color = pal[as.numeric(factor(vertex_attr(g10, "behavior"), levels = c("D", "C", "P")))])
  plot(g11, 
     layout = coords,  
     vertex.color = pal[as.numeric(factor(vertex_attr(g11, "behavior"), levels = c("D", "C", "P")))])
  plot(g12, 
     layout = coords,  
     vertex.color = pal[as.numeric(factor(vertex_attr(g12, "behavior"), levels = c("D", "C", "P")))])
  plot(g13, 
     layout = coords,  
     vertex.color = pal[as.numeric(factor(vertex_attr(g13, "behavior"), levels = c("D", "C", "P")))])
  plot(g14, 
     layout = coords,  
     vertex.color = pal[as.numeric(factor(vertex_attr(g14, "behavior"), levels = c("D", "C", "P")))])
  plot(g15, 
     layout = coords,  
     vertex.color = pal[as.numeric(factor(vertex_attr(g15, "behavior"), levels = c("D", "C", "P")))])
  },
  interval = 0.65, movie.name = "game1.gif")
```

```{r}
#Game 40
# ndata1_r0 = ndata1 %>% filter(game == 40, round == 0) %>% relocate(id) %>% unnest()
ndata1_r1 = ndata1 %>% filter(game == 40, round == 1) %>% relocate(id)
ndata1_r2 = ndata1 %>% filter(game == 40, round == 2) %>% relocate(id) 
ndata1_r3 = ndata1 %>% filter(game == 40, round == 3) %>% relocate(id) 
ndata1_r4 = ndata1 %>% filter(game == 40, round == 4) %>% relocate(id) 
ndata1_r5 = ndata1 %>% filter(game == 40, round == 5) %>% relocate(id) 
ndata1_r6 = ndata1 %>% filter(game == 40, round == 6) %>% relocate(id) 
ndata1_r7 = ndata1 %>% filter(game == 40, round == 7) %>% relocate(id) 
ndata1_r8 = ndata1 %>% filter(game == 40, round == 8) %>% relocate(id) 
ndata1_r9 = ndata1 %>% filter(game == 40, round == 9) %>% relocate(id) 
ndata1_r10 = ndata1 %>% filter(game == 40, round == 10) %>% relocate(id) 
ndata1_r11 = ndata1 %>% filter(game == 40, round == 11) %>% relocate(id) 
ndata1_r12 = ndata1 %>% filter(game == 40, round == 12) %>% relocate(id) 
ndata1_r13 = ndata1 %>% filter(game == 40, round == 13) %>% relocate(id) 
ndata1_r14 = ndata1 %>% filter(game == 40, round == 14) %>% relocate(id) 
ndata1_r15 = ndata1 %>% filter(game == 40, round == 15) %>% relocate(id) 

game40_round1_edgelist = ldata4 %>% filter(game == 40, round == 1) %>% dplyr::select(id1, id2)
g1 = graph_from_data_frame(game40_round1_edgelist, directed = T, vertices = ndata1_r1)
pal = brewer.pal(length(unique(V(g1)$behavior)), "Set1") #Red = D, Blue = C, Green = P
coords = layout.auto(g1)

game40_round2_edgelist = ldata4 %>% filter(game == 40, round == 2) %>% dplyr::select(id1, id2)
g2 = graph_from_data_frame(game40_round2_edgelist, directed = T, vertices = ndata1_r2)

game40_round3_edgelist = ldata4 %>% filter(game == 40, round == 3) %>% dplyr::select(id1, id2)
g3 = graph_from_data_frame(game40_round3_edgelist, directed = T, vertices = ndata1_r3)

game40_round4_edgelist = ldata4 %>% filter(game == 40, round == 4) %>% dplyr::select(id1, id2)
g4 = graph_from_data_frame(game40_round4_edgelist, directed = T, vertices = ndata1_r4)

game40_round5_edgelist = ldata4 %>% filter(game == 40, round == 5) %>% dplyr::select(id1, id2)
g5 = graph_from_data_frame(game40_round5_edgelist, directed = T, vertices = ndata1_r5)

game40_round6_edgelist = ldata4 %>% filter(game == 40, round == 6) %>% dplyr::select(id1, id2)
g6 = graph_from_data_frame(game40_round6_edgelist, directed = T, vertices = ndata1_r6)

game40_round7_edgelist = ldata4 %>% filter(game == 40, round == 7) %>% dplyr::select(id1, id2)
g7 = graph_from_data_frame(game40_round7_edgelist, directed = T, vertices = ndata1_r7)

game40_round8_edgelist = ldata4 %>% filter(game == 40, round == 8) %>% dplyr::select(id1, id2)
g8 = graph_from_data_frame(game40_round8_edgelist, directed = T, vertices = ndata1_r8)

game40_round9_edgelist = ldata4 %>% filter(game == 40, round == 9) %>% dplyr::select(id1, id2)
g9 = graph_from_data_frame(game40_round9_edgelist, directed = T, vertices = ndata1_r9)

game40_round10_edgelist = ldata4 %>% filter(game == 40, round == 10) %>% dplyr::select(id1, id2)
g10 = graph_from_data_frame(game40_round10_edgelist, directed = T, vertices = ndata1_r10)

game40_round11_edgelist = ldata4 %>% filter(game == 40, round == 11) %>% dplyr::select(id1, id2)
g11 = graph_from_data_frame(game40_round11_edgelist, directed = T, vertices = ndata1_r11)

game40_round12_edgelist = ldata4 %>% filter(game == 40, round == 12) %>% dplyr::select(id1, id2)
g12 = graph_from_data_frame(game40_round12_edgelist, directed = T, vertices = ndata1_r12)

game40_round13_edgelist = ldata4 %>% filter(game == 40, round == 13) %>% dplyr::select(id1, id2)
g13 = graph_from_data_frame(game40_round13_edgelist, directed = T, vertices = ndata1_r13)

game40_round14_edgelist = ldata4 %>% filter(game == 40, round == 14) %>% dplyr::select(id1, id2)
g14 = graph_from_data_frame(game40_round14_edgelist, directed = T, vertices = ndata1_r14)

game40_round15_edgelist = ldata4 %>% filter(game == 40, round == 15) %>% dplyr::select(id1, id2)
g15 = graph_from_data_frame(game40_round15_edgelist, directed = T, vertices = ndata1_r15)

# Game 40 animation
library(animation)

saveGIF({
  plot(g0, 
     layout = coords, 
     vertex.label = NA,
     vertex.color = pal[as.numeric(factor(vertex_attr(g0, "behavior"), levels = c("D", "C", "P")))])
  plot(g1, 
     layout = coords, 
     vertex.label = NA,
     vertex.color = pal[as.numeric(factor(vertex_attr(g1, "behavior"), levels = c("D", "C", "P")))])
  plot(g2, 
     layout = coords, 
     vertex.label = NA,
     vertex.color = pal[as.numeric(factor(vertex_attr(g2, "behavior"), levels = c("D", "C", "P")))])
  plot(g3, 
     layout = coords, 
     vertex.label = NA,
     vertex.color = pal[as.numeric(factor(vertex_attr(g3, "behavior"), levels = c("D", "C", "P")))])
  plot(g4, 
     layout = coords, 
     vertex.label = NA,
     vertex.color = pal[as.numeric(factor(vertex_attr(g4, "behavior"), levels = c("D", "C", "P")))])
  plot(g5, 
     layout = coords, 
     vertex.label = NA,
     vertex.color = pal[as.numeric(factor(vertex_attr(g5, "behavior"), levels = c("D", "C", "P")))])
  plot(g6, 
     layout = coords,  
     vertex.label = NA,
     vertex.color = pal[as.numeric(factor(vertex_attr(g6, "behavior"), levels = c("D", "C", "P")))])
  plot(g7, 
     layout = coords,  
     vertex.label = NA,
     vertex.color = pal[as.numeric(factor(vertex_attr(g7, "behavior"), levels = c("D", "C", "P")))])
  plot(g8, 
     layout = coords,  
     vertex.label = NA,
     vertex.color = pal[as.numeric(factor(vertex_attr(g8, "behavior"), levels = c("D", "C", "P")))]) 
  plot(g9, 
     layout = coords,  
     vertex.label = NA,
     vertex.color = pal[as.numeric(factor(vertex_attr(g9, "behavior"), levels = c("D", "C", "P")))])
  plot(g10, 
     layout = coords,  
     vertex.label = NA,
     vertex.color = pal[as.numeric(factor(vertex_attr(g10, "behavior"), levels = c("D", "C", "P")))])
  plot(g11, 
     layout = coords,  
     vertex.label = NA,
     vertex.color = pal[as.numeric(factor(vertex_attr(g11, "behavior"), levels = c("D", "C", "P")))])
  plot(g12, 
     layout = coords,  
     vertex.label = NA,
     vertex.color = pal[as.numeric(factor(vertex_attr(g12, "behavior"), levels = c("D", "C", "P")))])
  plot(g13, 
     layout = coords,  
     vertex.label = NA,
     vertex.color = pal[as.numeric(factor(vertex_attr(g13, "behavior"), levels = c("D", "C", "P")))])
  plot(g14, 
     layout = coords,  
     vertex.label = NA,
     vertex.color = pal[as.numeric(factor(vertex_attr(g14, "behavior"), levels = c("D", "C", "P")))])
  plot(g15, 
     layout = coords,  
     vertex.label = NA,
     vertex.color = pal[as.numeric(factor(vertex_attr(g15, "behavior"), levels = c("D", "C", "P")))])
  },
  interval = 0.65, movie.name = "game40.gif")
```

```{r}
#Game 44
# ndata1_r0 = ndata1 %>% filter(game == 44, round == 0) %>% relocate(id) %>% unnest()
ndata1_r1 = ndata1 %>% filter(game == 44, round == 1) %>% relocate(id)
ndata1_r2 = ndata1 %>% filter(game == 44, round == 2) %>% relocate(id) 
ndata1_r3 = ndata1 %>% filter(game == 44, round == 3) %>% relocate(id) 
ndata1_r4 = ndata1 %>% filter(game == 44, round == 4) %>% relocate(id) 
ndata1_r5 = ndata1 %>% filter(game == 44, round == 5) %>% relocate(id) 
ndata1_r6 = ndata1 %>% filter(game == 44, round == 6) %>% relocate(id) 
ndata1_r7 = ndata1 %>% filter(game == 44, round == 7) %>% relocate(id) 
ndata1_r8 = ndata1 %>% filter(game == 44, round == 8) %>% relocate(id) 
ndata1_r9 = ndata1 %>% filter(game == 44, round == 9) %>% relocate(id) 
ndata1_r10 = ndata1 %>% filter(game == 44, round == 10) %>% relocate(id) 
ndata1_r11 = ndata1 %>% filter(game == 44, round == 11) %>% relocate(id) 
ndata1_r12 = ndata1 %>% filter(game == 44, round == 12) %>% relocate(id) 
ndata1_r13 = ndata1 %>% filter(game == 44, round == 13) %>% relocate(id) 
ndata1_r14 = ndata1 %>% filter(game == 44, round == 14) %>% relocate(id) 
ndata1_r15 = ndata1 %>% filter(game == 44, round == 15) %>% relocate(id) 

game44_round1_edgelist = ldata4 %>% filter(game == 44, round == 1) %>% dplyr::select(id1, id2)
g1 = graph_from_data_frame(game44_round1_edgelist, directed = T, vertices = ndata1_r1)
pal = brewer.pal(length(unique(V(g1)$behavior)), "Set1") #Red = D, Blue = C, Green = P
coords = layout.auto(g1)

game44_round2_edgelist = ldata4 %>% filter(game == 44, round == 2) %>% dplyr::select(id1, id2)
g2 = graph_from_data_frame(game44_round2_edgelist, directed = T, vertices = ndata1_r2)

game44_round3_edgelist = ldata4 %>% filter(game == 44, round == 3) %>% dplyr::select(id1, id2)
g3 = graph_from_data_frame(game44_round3_edgelist, directed = T, vertices = ndata1_r3)

game44_round4_edgelist = ldata4 %>% filter(game == 44, round == 4) %>% dplyr::select(id1, id2)
g4 = graph_from_data_frame(game44_round4_edgelist, directed = T, vertices = ndata1_r4)

game44_round5_edgelist = ldata4 %>% filter(game == 44, round == 5) %>% dplyr::select(id1, id2)
g5 = graph_from_data_frame(game44_round5_edgelist, directed = T, vertices = ndata1_r5)

game44_round6_edgelist = ldata4 %>% filter(game == 44, round == 6) %>% dplyr::select(id1, id2)
g6 = graph_from_data_frame(game44_round6_edgelist, directed = T, vertices = ndata1_r6)

game44_round7_edgelist = ldata4 %>% filter(game == 44, round == 7) %>% dplyr::select(id1, id2)
g7 = graph_from_data_frame(game44_round7_edgelist, directed = T, vertices = ndata1_r7)

game44_round8_edgelist = ldata4 %>% filter(game == 44, round == 8) %>% dplyr::select(id1, id2)
g8 = graph_from_data_frame(game44_round8_edgelist, directed = T, vertices = ndata1_r8)

game44_round9_edgelist = ldata4 %>% filter(game == 44, round == 9) %>% dplyr::select(id1, id2)
g9 = graph_from_data_frame(game44_round9_edgelist, directed = T, vertices = ndata1_r9)

game44_round10_edgelist = ldata4 %>% filter(game == 44, round == 10) %>% dplyr::select(id1, id2)
g10 = graph_from_data_frame(game44_round10_edgelist, directed = T, vertices = ndata1_r10)

game44_round11_edgelist = ldata4 %>% filter(game == 44, round == 11) %>% dplyr::select(id1, id2)
g11 = graph_from_data_frame(game44_round11_edgelist, directed = T, vertices = ndata1_r11)

game44_round12_edgelist = ldata4 %>% filter(game == 44, round == 12) %>% dplyr::select(id1, id2)
g12 = graph_from_data_frame(game44_round12_edgelist, directed = T, vertices = ndata1_r12)

game44_round13_edgelist = ldata4 %>% filter(game == 44, round == 13) %>% dplyr::select(id1, id2)
g13 = graph_from_data_frame(game44_round13_edgelist, directed = T, vertices = ndata1_r13)

game44_round14_edgelist = ldata4 %>% filter(game == 44, round == 14) %>% dplyr::select(id1, id2)
g14 = graph_from_data_frame(game44_round14_edgelist, directed = T, vertices = ndata1_r14)

game44_round15_edgelist = ldata4 %>% filter(game == 44, round == 15) %>% dplyr::select(id1, id2)
g15 = graph_from_data_frame(game44_round15_edgelist, directed = T, vertices = ndata1_r15)

# Game 44 animation
library(animation)

saveGIF({
  plot(g1, 
     layout = coords, 
     vertex.label = NA,
     vertex.color = pal[as.numeric(factor(vertex_attr(g1, "behavior"), levels = c("D", "C", "P")))])
  plot(g2, 
     layout = coords, 
     vertex.label = NA,
     vertex.color = pal[as.numeric(factor(vertex_attr(g2, "behavior"), levels = c("D", "C", "P")))])
  plot(g3, 
     layout = coords, 
     vertex.label = NA,
     vertex.color = pal[as.numeric(factor(vertex_attr(g3, "behavior"), levels = c("D", "C", "P")))])
  plot(g4, 
     layout = coords, 
     vertex.label = NA,
     vertex.color = pal[as.numeric(factor(vertex_attr(g4, "behavior"), levels = c("D", "C", "P")))])
  plot(g5, 
     layout = coords, 
     vertex.label = NA,
     vertex.color = pal[as.numeric(factor(vertex_attr(g5, "behavior"), levels = c("D", "C", "P")))])
  plot(g6, 
     layout = coords,  
     vertex.label = NA,
     vertex.color = pal[as.numeric(factor(vertex_attr(g6, "behavior"), levels = c("D", "C", "P")))])
  plot(g7, 
     layout = coords,  
     vertex.label = NA,
     vertex.color = pal[as.numeric(factor(vertex_attr(g7, "behavior"), levels = c("D", "C", "P")))])
  plot(g8, 
     layout = coords,  
     vertex.label = NA,
     vertex.color = pal[as.numeric(factor(vertex_attr(g8, "behavior"), levels = c("D", "C", "P")))]) 
  plot(g9, 
     layout = coords,  
     vertex.label = NA,
     vertex.color = pal[as.numeric(factor(vertex_attr(g9, "behavior"), levels = c("D", "C", "P")))])
  plot(g10, 
     layout = coords,  
     vertex.label = NA,
     vertex.color = pal[as.numeric(factor(vertex_attr(g10, "behavior"), levels = c("D", "C", "P")))])
  plot(g11, 
     layout = coords,  
     vertex.label = NA,
     vertex.color = pal[as.numeric(factor(vertex_attr(g11, "behavior"), levels = c("D", "C", "P")))])
  plot(g12, 
     layout = coords,  
     vertex.label = NA,
     vertex.color = pal[as.numeric(factor(vertex_attr(g12, "behavior"), levels = c("D", "C", "P")))])
  plot(g13, 
     layout = coords,  
     vertex.label = NA,
     vertex.color = pal[as.numeric(factor(vertex_attr(g13, "behavior"), levels = c("D", "C", "P")))])
  plot(g14, 
     layout = coords,  
     vertex.label = NA,
     vertex.color = pal[as.numeric(factor(vertex_attr(g14, "behavior"), levels = c("D", "C", "P")))])
  plot(g15, 
     layout = coords,  
     vertex.label = NA,
     vertex.color = pal[as.numeric(factor(vertex_attr(g15, "behavior"), levels = c("D", "C", "P")))])
  },
  interval = 0.65, movie.name = "game44.gif")
```

## 3. Determining the influence of different harming patterns

Finding 3) When people are harmed by two or more of the connecting neighbors, they are more likely to choose to harm the connecting neighbors; on the other hand, when people are harmed by only one of the connecting neighbors, their rate of harming choice is the same as that when they are harmed by no one. -> It implies that people in modern societies generally take a generous strategy in the present experiment setting, in which they can prevent their revengeful harming from indiscriminately harming all the connecting neighbors including harmers and non-harmers (cooperators or defectors). And, there is a threshold - such a threshold may work as a stopper of the vicious cycle of harming behavior.  OR one-shot really works as a cooperation enhancer? (but two harmers may produce harming trends?)
[note: yes, a gunshot has a mistake] [note: dose-response for the number of innocent neighbors? only connecting with harmers may make revenge an easy option, "deterrent"??]

```{r}
data3 = data1 %>% 
  filter(round != 0) %>%
  mutate(count_local_coop_lag = e_degree * local_rate_coop_lag,
         count_local_defect_lag = e_degree * local_rate_defect_lag,
         count_local_punish_lag = e_degree *  local_rate_punish_lag)
hist(data3$count_local_coop_lag)
hist(data3$count_local_defect_lag)
hist(data3$count_local_punish_lag)
```
```{r}
data3 %>% 
  filter(count_local_coop_lag == 0) %>%
  ggplot() + 
  geom_histogram(aes(x = e_degree), bins = 20)

data3 %>% filter(count_local_punish_lag >= 2)

data3 %>% filter(count_local_punish_lag >= 2) %>% tally(behavior_coop) #78
data3 %>% filter(count_local_punish_lag >= 2) %>% tally(behavior_defect) #172
data3 %>% filter(count_local_punish_lag >= 2) %>% tally(behavior_punish) #17
# Coop rate - 78/267 = 29%, Defect rate = 64%, Punish rate = 6.4%
17/267

data3 %>% filter(count_local_punish_lag == 1) %>% tally(behavior_coop) #217
data3 %>% filter(count_local_punish_lag == 1) %>% tally(behavior_defect) #300
data3 %>% filter(count_local_punish_lag == 1) %>% tally(behavior_punish) #38)
# Coop rate - 217/555 = 39%, defect rate = 54%, punish rate = 6.8%

data3 %>% filter(count_local_punish_lag == 0) %>% tally(behavior_coop) #3632
data3 %>% filter(count_local_punish_lag == 0) %>% tally(behavior_defect) #2869
data3 %>% filter(count_local_punish_lag == 0) %>% tally(behavior_punish) #359
# C: 3632/6860 = 53%, D: 42%, P: 5.2%
```
Next: how to show this in regression model?

```{r}
load("~/Documents/Projects/harming_esn/Data/nodedataHarming.rdata") 
names(ndata)
#ndata is the node data
harmdata = ndata
#making superid
table(ndata$game)

harmdata$superid = 20000 + 100 * harmdata$game + 
  as.numeric(substr(harmdata$id,2,nchar(harmdata$id)))
#2XXXX for the harming experiment

#local_rate_coop and other detailed data
#This will be done when we need other variables.
#mdata2 is the link data
load("~/Documents/Projects/harming_esn/Data/Harminglinknodedata.Rdata")
harmlinknode = mdata2
harmlinknode = harmlinknode[,c("superid", "round", 
                               "cur_local_rate_coop", "n_ties")]
names(harmlinknode)[3] = "local_rate_coop"
names(harmlinknode)[4] = "degree"
harmlinknode$superid = 20000 + harmlinknode$superid
harmdata = merge(x = harmdata,
                 y = harmlinknode,
                 by = c("superid","round"), all=T) #10727
names(harmdata)

###a function to standardize
standardize = function(x) {
  mu = mean(x, na.rm = T)
  sd = sd(x, na.rm = T) 
  return ((x - mu)/sd)
}

###making a continuous variable of happiness
harmdata$happ = ifelse(harmdata$satisfaction == "v_good", 2, 
                 ifelse(harmdata$satisfaction == "good", 1, 
                 ifelse(harmdata$satisfaction == "neutral", 0,
                 ifelse(harmdata$satisfaction == "bad", -1, 
                 ifelse(harmdata$satisfaction == "v_bad", -2, NA)))))

###making PosWealth (when <0, 0)
harmdata$PosWealth = ifelse(harmdata$cumulativePayoff >= 0, 
                            harmdata$cumulativePayoff, 0)

#making cPayoffS (standardized cumulative payoff, 
#gini_wealth, and gini_wellbeing)
HarmStandard = as.data.frame(matrix(NA, ncol = ncol(harmdata) + 3, nrow = 0))
names(HarmStandard) = c(names(harmdata), "cPayoffS", "gini_wealth", 
                        "gini_wellbeing")
for (i in 0:max(harmdata$round)){   #number of rounds 
  for (j in 1:max(harmdata$game)){ #number of games
    temp = harmdata[(harmdata$game == j & harmdata$round == i), ]
    temp$cPayoffS = standardize(temp$cumulativePayoff)
    temp$gini_wealth = gini(temp$PosWealth)
    temp$gini_wellbeing = gini(temp$happ)
    HarmStandard = rbind(HarmStandard, temp)
  }
} 

###Making 5 wealth categories
HarmStandard = HarmStandard %>%
  mutate(WealthLevel = case_when(cPayoffS < -1.5 ~ "Poorest",
                                 cPayoffS >= -1.5 & cPayoffS < -0.5  ~ "Poorer",
                                 cPayoffS >= -0.5 & cPayoffS < 0.5  ~ "Middle",
                                 cPayoffS >= 0.5 & cPayoffS < 1.5  ~ "Richer",
                                 cPayoffS >= 1.5  ~ "Richest"))

#Making a 0/1 cooperation variable
HarmStandard = HarmStandard %>%
  mutate(coop = case_when(behavior == "C" ~ 1,behavior %in% c("D","P","") ~ 0))

HarmStandard$showScore = ifelse(HarmStandard$showScore=="true",1,0)

###Renaming game ID as well (1XX for Happ, 2XX for Harm)
HarmStandard$game = 200 + HarmStandard$game

###making the variable names the same over the two data
HarmStandard = HarmStandard[,!(names(HarmStandard) == "gameNumber")]

#Harm variable
HarmStandard$harm = ifelse(HarmStandard$behavior=="P",1,0)

#Other variables
HarmStandard$age = as.numeric(unlist(HarmStandard$age))
HarmStandard$gender = as.character(unlist(HarmStandard$gender))
HarmStandard$behaviorTime = as.numeric(unlist(HarmStandard$behaviorTime))

#Making the minimum data
names(HarmStandard)
HarmStandard %>% dplyr::select(game, superid, round, age, gender, showScore,
                               initScore, payoff, cumulativePayoff, cPayoffS,
                               WealthLevel, coop, local_rate_coop, degree, happ,
                               harm,behaviorTime)
data0  = HarmStandard[,c("game","superid","round","age","gender","showScore",
                         "initScore","payoff","cumulativePayoff","cPayoffS",
                         "WealthLevel","coop","local_rate_coop","degree",
                         "happ","harm","behaviorTime")]

#Making a lag data
data_lag = data0[,c("superid","round",
                    "initScore","payoff","cumulativePayoff","cPayoffS",
                    "WealthLevel","coop","local_rate_coop","degree",
                    "happ","harm","behaviorTime")]
names(data_lag)[-c(1,2)] = paste0(names(data_lag)[-c(1,2)],"_lag")
data_lag$round = data_lag$round + 1

#merge
data1 = merge(x=data0,y=data_lag,all.x=T,all.y=F,by=c("superid","round"))

data1$log_behaviorTime = log10(data1$behaviorTime)
data1$log_behaviorTime_lag = log10(data1$behaviorTime_lag)

#checking for data consistency
table(data1$coop) # difference is the blanks were not converted to not coop
# 5104/4878

summary(zelig(data = data1, coop ~ showScore + age + gender, model = "logit"))
# showscore = -0.195
```

