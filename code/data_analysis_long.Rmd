---
title: "Evolution of Punishment and Peace in Experimental Social Networks"
author: "George Dewey, Hiroyasu Ando, Ryo Ikesu, Akihiro Nishi"
date: "`r Sys.Date()`"
output:
  pdf_document: default
  html_document: default
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

This R Markdown document contains the data analysis and visualization code for our paper "Evolution of Peace and Punishment in Experimental Social Networks."

# Variable Definitions

-   `age`: player's age
-   `gender`: player's gender (male or female)
-   `behavior`: behavior in the current round (C: Cooperation; D: Defection, P: Punishment)
-   `initial_score`: score before the games (200 or 1150)
-   `behavior_coop`: indicator variable for cooperation of ego in round *t*
-   `behavior_defect`: indicator variable for defection of ego in round *t*
-   `behavior_punish`: indicator variable for punishment of ego in round *t*
-   `behavior_coop_lag`: indicator variable for cooperation of ego in round *t-1*
-   `behavior_punish_lag`: indicator variable for punishment of ego in round *t-1*
-   `local_rate_coop_lag`: proportion of cooperation among alters of ego in round *t-1*
-   `local_rate_punish_lag`: proportion of punishment among alters of ego in round *t-1*
-   `local_rate_punish_lag_cat3`: 3-category variable for `local_rate_punish_lag` (1: 0-5%, 2: 5-15, 3: \>15%)
-   `local_rate_punish_lag_cat6`: 6-category variable for `local_rate_punish_lag` (1: 0-5%, 2: 5-10%, 3: 10-15%, 4: 15-20%, 5: 20-25%, 6: \>25%)
-   `local_rate_coop_cat5`: 5-category variable for `local_rate_coop_lag` (1: \>80%, 2: 60-80%, 3: 30-60%, 4: 10-30%, 5: 0-10%)
-   `log_behaviorTime`: time to choose behavior (unit: log milliseconds)
-   `log_behaviorTime_lag`: time to choose behavior (unit: log milliseconds)
-   `behaviorTime_sec`: time to choose behavior (unit: seconds)
-   `cPayoffS_lag`: standardized cumulative payoff/wealth in round *t-1*
-   `conflict`: indicator variable for the proportion of punishment among alters in round *t-1* exceeding 15%
-   `degree_lag`: the number of ties/connecting neighbors in round *t-1*
-   `happ_lag`: subjective well-being in round *t-1*
-   `showScore`: is wealth of connecting neighbors visible (1) or invisible (0)
-   `transitivity`: the measure of the tendency of network nodes to cluster together

# Data Management

## Clear any existing data in memory
```{r}
rm(list = ls())
```


## Load packages and establish helper functions

```{r, message = F, warning = F}
library(tidyverse) # for data management
library(data.table) # for table management
library(reshape2) # for data management
library(magrittr) # for data management
library(lme4) # for mixed effects regression
library(lmerTest) # for p-values in regression output
library(reldist) # to calculate gini
library(rgeolocate) # to convert IPs to country
library(igraph) # for network analysis
library(gtable) # for visualization
library(grid) # for visualization
library(ggsignif) # for error bars
library(cowplot) # for visualization
library(gridExtra) # for visualization
library(reldist) # to calculate gini
library(sjPlot) # for tables
library(binom) # for generating confidence intervals
library(broom.mixed) # for mixed effects models output


mean1 = function(x) {mean(x,na.rm=TRUE)}
median1 = function(x) {median(x, na.rm = TRUE)}
```

## Load data

```{r}
# 4 main datasets: 
# harmdata - cleaned raw individual-level data 
# ldata4 - tie component of network-level data
# ndata1 - node component of network-level data
# data1 - main aggregated dataset including lag (rounds t-1, t-2, etc.) data

# harmdata
load("~/Documents/Projects/harming_esn/Data/exp1/harmdata.Rdata") #harmdata

# ldata4
load("~/Documents/Projects/harming_esn/Data/exp1/ldata4_0316X.Rdata")

# ndata1
load("~/Documents/Projects/harming_esn/Data/exp1/ndata_individual.Rdata")

# data1
load("~/Documents/Projects/harming_esn/Data/exp1/data1.Rdata") #data1
```

## Create complete case dataset for regression + figures

```{r}
# Exclude rows with missing data - no behavior etc.
# transform the scale of behavior time from msec to sec 
data1$behaviorTime_sec = (data1$behaviorTime)/1000

#replace NaNs (from missing lag data) with NAs
# regression models do not use rows with missing values
data1b = data1 
data1_cc = na.omit(data1b)
dim(data1_cc)

# Create categorical behavior
data1_cc = data1_cc %>% mutate(behavior = case_when(behavior_coop == 1 ~ "C",
                                      behavior_defect == 1 ~ "D",
                                      behavior_punish == 1 ~ "P"),
                 behavior_lag = case_when(behavior_coop_lag == 1 ~ "C",
                                          behavior_defect_lag ==1 ~ "D",
                                          behavior_punish_lag == 1 ~ "P"),
                 behavior_lag2 = case_when(behavior_coop_lag2 == 1 ~ "C",
                                           behavior_defect_lag2 == 1 ~ "D",
                                            behavior_punish_lag2 == 1 ~ "P"))

## Creating the categorical variable for local punish rate in round t-1 
data1_cc$local_rate_punish_cat4 = 
  case_when(data1_cc$local_rate_punish_lag >=0 & data1_cc$local_rate_punish_lag <= 0.05 ~ 0,
            data1_cc$local_rate_punish_lag > 0.05 & data1_cc$local_rate_punish_lag <= 0.1 ~ 1,
            data1_cc$local_rate_punish_lag > 0.1 & data1_cc$local_rate_punish_lag <= 0.15 ~ 2,
            data1_cc$local_rate_punish_lag > 0.15 & data1_cc$local_rate_punish_lag <= 0.2 ~ 3,
            data1_cc$local_rate_punish_lag > 0.2 & data1_cc$local_rate_punish_lag <= 0.25 ~ 4,
            data1_cc$local_rate_punish_lag > 0.25 ~ 5)

# categorical variable for the prevalence of punishment behavior 
# in the previous round
data1_cc$local_rate_punish_cat3 =
  case_when(data1_cc$local_rate_punish_lag == 0 ~ 1,
            data1_cc$local_rate_punish_lag > 0 & 
              data1_cc$local_rate_punish_lag <= 0.15 ~ 2,
            data1_cc$local_rate_punish_lag > 0.15 ~ 3)

data1_cc$local_rate_punish_cat6 = 
  case_when(data1_cc$local_rate_punish_lag <= 0.05 ~ 1,
            data1_cc$local_rate_punish_lag > 0.05 &
              data1_cc$local_rate_punish_lag <= 0.1 ~ 2,
            data1_cc$local_rate_punish_lag > 0.1 &
              data1_cc$local_rate_punish_lag <= 0.15 ~ 3,
            data1_cc$local_rate_punish_lag > 0.15 &
              data1_cc$local_rate_punish_lag <= 0.2 ~ 4,
            data1_cc$local_rate_punish_lag > 0.2 &
              data1_cc$local_rate_punish_lag <= 0.25 ~ 5,
            data1_cc$local_rate_punish_lag > 0.25 ~ 6) %>% as.factor()

data1_cc$local_rate_coop_cat5 = 
  case_when(data1_cc$local_rate_coop_lag > 0 & data1_cc$local_rate_coop_lag <= 0.1 ~ 5,
            data1_cc$local_rate_coop_lag > 0.1 & data1_cc$local_rate_coop_lag <= 0.3 ~ 4,
            data1_cc$local_rate_coop_lag > 0.3 & data1_cc$local_rate_coop_lag <= 0.6 ~ 3,
            data1_cc$local_rate_coop_lag > 0.6 & data1_cc$local_rate_coop_lag <= 0.8 ~ 2,
            data1_cc$local_rate_coop_lag > 0.8  ~ 1)

# indicator variable for the punishment prevalence
data1_cc = 
  data1_cc %>% 
  mutate(conflict = ifelse(local_rate_punish_lag > 0.15,1,0) %>% as.factor(),
         conflict2 = 
           ifelse(local_rate_punish_lag >= 0.15, 1, 0) %>% as.factor()) %>% 
  as.data.table()
```

# Descriptive Statistics

Summary of basic statistics about the player population/games played.

```{r}
# Checking sample size
dim(harmdata) #10727 recorded actions
length(unique(harmdata$superid)) #745 unique participants 

# showScore
table(harmdata$showScore) # wealth visibility - balanced as intended

# Demographics
r2df = harmdata %>% filter(round == 2)
length(harmdata %>% filter(round == 2) %>% pull(unique(superid))) 
#713 individuals through round 2

# Age
mean1(harmdata$age) #32.86 years

# Gender
xtabs(~gender, r2df) # 499 provided gender, F: 206 (41%) vs M: 392 (59%)

# Country
xtabs(~country_3cat, r2df) #408 (57%) US, 257 (36%) India, 7% Other
  length(unique(harmdata$country)) #27 unique countries

# Behavior time
mean(harmdata$behaviorTime, na.rm = T) # ~7870 ms

# Behaviors
table(harmdata$behavior_coop) #4878 coop (45.5%)
table(harmdata$behavior_defect) #4336 defect (40.4%)
table(harmdata$behavior_punish) #562 punish (5.2%)

# cumulativePayoff
table(factor(harmdata$initial_score)) # 70% low, 30% high
mean(harmdata$cumulativePayoff, na.rm =T) #1584 (so mean gain of ~ 1500 units)
# overall a gain - players started with 200 (low) or 1150 units (high)

# degree
mean1(harmdata$degree) #6

# transitivity
mean1(data1$transitivity)

# How many rounds with and without punishments?
peace_rounds = NULL
punish_rounds = NULL
for(i in 1:50){
  tmp = harmdata %>% filter(game == i, round !=0) %>% group_by(round) %>% 
  tally(behavior_punish) %>% group_by(n) %>% summarize(round_count = n())
  peace_rounds = c(peace_rounds, 
                   sum(tmp %>% filter(n == 0) %>% pull(round_count)))
  punish_rounds = c(punish_rounds, 
                    sum(tmp %>% filter(n != 0) %>% pull(round_count)))
}

sum(peace_rounds) #377 rounds with no punish choice
sum(punish_rounds) #373 rounds with at least 1 punish choice
```

# Figures

## Figure 1: Trajectory of wealth, behavior, and network structures, stratified by wealth visibility

```{r, message = F, warning = F}
# Set up additional convenience functions
length1 <- function(x) {length(na.omit(x))}
se1 <- function(x){sd(x, na.rm = TRUE)/sqrt(length(na.omit(x)))}
se2 <- function(x) {sqrt(mean1(x)*(1-mean1(x))/length1(x))}

# Standardized cumulative wealth (standardized within each network session)
data1_wealth <- data1 %>% group_by(round, showScore) %>% 
  summarise(wealth_mean = mean(cPayoffS), wealth_se = se1(cPayoffS))

tr_wealth <- ggplot(data1_wealth, aes(x = round, y = wealth_mean,
                                      linetype = factor(showScore))) +
  geom_line() +
  geom_errorbar(aes(ymin = wealth_mean - wealth_se,
                    ymax = wealth_mean + wealth_se),
                width=0, cex = 0.7, alpha = 0.3) +
  labs(x = "Round", y = "Cumulative wealth \n(standardized)",
       linetype = "Wealth visibility") + 
  ggtitle("a") +
  scale_x_continuous(breaks = seq(0, 15, 2)) +
  scale_y_continuous(breaks = seq(-2, 2, 0.5)) +
  scale_linetype_manual(labels = c("Invisible", "Visible"),
                        values = c("dashed", "solid")) + 
  theme_classic() + 
  theme(legend.position = "top",
        plot.title = element_text(size = 16, face = "bold"))

# Extract the legend info.
## https://note.com/eiko_dokusho/n/n8abcf3a08903
g1<- ggplotGrob(tr_wealth)
id.legend <- grep("guide", g1$layout$name)
legend <- g1[["grobs"]][[id.legend]]

# Network degree
# summary(data1$degree)
# data1[is.na(data1$degree),"degree"] <- 0
# summary(data1$degree)

data1_degree <- data1 %>%
  group_by(round, showScore) %>% 
  summarise(degree_mean = mean(degree),
            degree_se = se1(degree))

tr_degree <- ggplot(data1_degree, aes(x = round, y = degree_mean,
                                      linetype = factor(showScore))) +
  geom_line() +
  geom_errorbar(aes(ymin = degree_mean - degree_se,
                    ymax = degree_mean + degree_se),
                width=0, cex = 0.7, alpha = 0.3) +
  labs(x = "Round", y = "Network degree",
       linetype = "Wealth visibility") + 
  ggtitle("b") +
  scale_x_continuous(breaks = seq(0, 15, 2)) +
  scale_y_continuous(breaks = seq(0, 10, 2.5), limits = c(0,10)) +
  scale_linetype_manual(labels = c("Invisible", "Visible"),
                        values = c("dashed", "solid")) + 
  theme_classic() +
  theme(legend.position = "none",
        plot.title = element_text(size = 16, face = "bold"))

# Network transitivity
# summary(data1$transitivity)
# data1[is.na(data1$transitivity),"transitivity"] <- 0
# summary(data1$transitivity)

data1_transitivity <- data1 %>%
  group_by(round, showScore) %>% 
  summarise(transitivity_mean = mean1(transitivity),
            transitivity_se = se2(transitivity))

tr_transitivity <- ggplot(data1_transitivity, aes(x = round, y = transitivity_mean,
                                      linetype = factor(showScore))) +
  geom_line() +
  geom_errorbar(aes(ymin = transitivity_mean - transitivity_se,
                    ymax = transitivity_mean + transitivity_se),
                width=0, cex = 0.7, alpha = 0.3) +
  labs(x = "Round", y = "Network transitivity",
       linetype = "Wealth visibility") + 
  ggtitle("c") +
  scale_x_continuous(breaks = seq(0, 15, 2)) +
  scale_y_continuous(breaks = seq(0, 1, 0.25), limits = c(0,1)) +
  scale_linetype_manual(labels = c("Invisible", "Visible"),
                        values = c("dashed", "solid")) + 
  theme_classic() +
  theme(legend.position = "none",
        plot.title = element_text(size = 16, face = "bold"))

# Proportion of cooperation
data1_coop <- data1 %>%
  filter(round != 0) %>% 
  group_by(round, showScore) %>% 
  summarise(coop_mean = mean(behavior_coop),
            coop_se = se2(behavior_coop))

tr_coop <- ggplot(data1_coop, aes(x = round, y = coop_mean,
                                  linetype = factor(showScore))) +
  geom_line() +
  geom_errorbar(aes(ymin = coop_mean - coop_se,
                    ymax = coop_mean + coop_se),
                width=0, cex = 0.7, alpha = 0.3) +
  labs(x = "Round", y = "Proportion of cooperation",
       linetype = "Wealth visibility") + 
  ggtitle("d") +
  scale_x_continuous(breaks = seq(1, 15, 2)) +
  scale_y_continuous(breaks = seq(0, 0.7, 0.1), limits = c(0,0.7)) +
  scale_linetype_manual(labels = c("Invisible", "Visible"),
                        values = c("dashed", "solid")) + 
  theme_classic() +
  theme(legend.position = "none",
        plot.title = element_text(size = 16, face = "bold"))

# Proportion of punishment
data1_punish <- data1 %>%
  filter(round != 0) %>%
  group_by(round, showScore) %>%
  summarise(punish_mean = mean(behavior_punish),
            punish_se = se2(behavior_punish))

tr_punish <- ggplot(data1_punish, aes(x = round, y = punish_mean,
                                      linetype = factor(showScore))) +
  geom_line() +
  geom_errorbar(aes(ymin = punish_mean - punish_se,
                    ymax = punish_mean + punish_se),
                width=0, cex = 0.7, alpha = 0.3) +
  labs(x = "Round", y = "Proportion of punishment",
       linetype = "Wealth visibility") + 
  ggtitle("e") +
  scale_x_continuous(breaks = seq(1, 15, 2)) +
  scale_y_continuous(breaks = seq(0, 0.3, 0.1), limits = c(0,0.3)) +
  scale_linetype_manual(labels = c("Invisible", "Visible"),
                        values = c("dashed", "solid")) + 
  theme_classic() + 
  theme(legend.position = "none",
        plot.title = element_text(size = 16, face = "bold"))

# Make a figure panel
layout <- rbind(c(1, 1, 1),
                c(2, 3, 4),
                c(5, 6, NA))
network_panel <- grid.arrange(legend,
             tr_wealth + theme(legend.position = "none"),
             tr_degree,tr_transitivity,
             tr_coop, tr_punish,
             layout_matrix = layout,
             heights = c(.1, .45, .45))

# path_to_figures <- "~/Desktop/"
# ggsave(paste0(path_to_figures, "network_panel_2022_06_18.png"),
#        plot = network_panel, width = 20, height = 12, units = "cm")
```

## Figure 2: Density/rug plot of behavior time (log-scale) by conflict status

```{r}
data1_cc$ypos <- 0
data1_cc$ypos2 <- 0 #for sub-plots
data1_cc[behavior_coop==1, ypos:=0.06]
data1_cc[behavior_defect==1, ypos:=0.03]
data1_cc[conflict==1, ypos2:=0.1]
# xtabs(~ypos+behavior, data = data1_cc)

d_plot <- data1_cc %>%
  na.omit() %>%
  ggplot(aes(x=behaviorTime_sec, colour=behavior)) +
  geom_density(adjust = 2) +
  theme_classic() +
  labs(color = "Behavior") +
  scale_x_log10(limits = c(1, 110),breaks = c(1, 10, 100)) +
  scale_y_continuous(limits = c(0, 1.3)) +
  scale_color_manual(labels = c("Cooperation", "Defection", "Punishment"),
                     values = c("orange2", "skyblue2", "red2")) +
  guides(colour=guide_legend(title = NULL))

d_plot_f <- d_plot +
  theme(axis.title = element_blank(),
        axis.text = element_text(size = rel(1.3)),
        legend.position = c(0.8, 0.8)) +
  geom_point(aes(x=behaviorTime_sec, y=ypos, colour=behavior),
             position = position_jitter(width = 0.2, height = 0),
             alpha=0.03)

d_plot_oc = data1_cc %>%
  na.omit() %>%
  filter(conflict == 0) %>%
  ggplot(aes(x=behaviorTime_sec, colour=behavior)) +
  geom_density(adjust = 2) +
  theme_classic() +
  labs(color = "Behavior") +
  scale_x_log10(limits = c(1, 110),breaks = c(1, 10, 100)) +
  scale_y_continuous(limits = c(0, 1.3)) +
  scale_color_manual(labels = c("Cooperation", "Defection", "Punishment"),
                     values = c("orange2", "skyblue2", "red2")) +
  guides(colour=guide_legend(title = NULL))+
  theme(axis.title = element_blank(),
        axis.text = element_text(size = rel(1.3)),
        legend.position = "none") +
  geom_point(aes(x=behaviorTime_sec, y=ypos, colour=behavior),
             position = position_jitter(width = 0.2, height = 0),
             alpha=0.03)

d_plot_ic = data1_cc %>%
  na.omit() %>%
  filter(conflict == 1) %>%
  ggplot(aes(x=behaviorTime_sec, colour=behavior)) +
  geom_density(adjust = 2) +
  theme_classic() +
  labs(color = "Behavior") +
  scale_x_log10(limits = c(1, 110),breaks = c(1, 10, 100)) +
  scale_y_continuous(limits = c(0, 1.3)) +
  scale_color_manual(labels = c("Cooperation", "Defection", "Punishment"),
                     values = c("orange2", "skyblue2", "red2")) +
  guides(colour=guide_legend(title = NULL))+
  theme(axis.title = element_blank(),
        axis.text = element_text(size = rel(1.3)),
        legend.position = "none") +
  geom_point(aes(x=behaviorTime_sec, y=ypos, colour=behavior),
             position = position_jitter(width = 0.2, height = 0),
             alpha=0.03)

grid.arrange(d_plot_f,
             d_plot_oc,
             d_plot_ic,
             layout_matrix = layout)

right_col = cowplot::plot_grid(d_plot_oc, d_plot_ic,
                               ncol = 1,
                               labels = c("No conflict", "  In conflict"))


fig2B = cowplot::plot_grid(d_plot_f, right_col, nrow = 1)

grid.arrange(fig2B,
             bottom = textGrob("Decision time (sec)",gp=gpar(fontsize=15)),
            left = textGrob("Density",gp=gpar(fontsize=15), rot = 90))

# data1_cc %>%
#   na.omit() %>%
#   filter(behavior_punish == 1) %>%
#   ggplot() +
#   geom_density(aes(x=behaviorTime_sec, color = local_rate_punish_cat6)) +
#   scale_color_manual(labels = c("[0,5]", "(5, 10]", "(10, 15]",
#                                   "(15, 20]", "(20, 25]", "(25, 100]"),
#                        values = c("green", "gold", "orange", "pink", "red", "darkred"))
```

## Figure 3: Demonstrating the threshold of punishment based on prevalence of punishment among alters in round *t-1*

```{r}
#prepare a data.frame to depict the box plot
data1_p_cat1 = data1_cc[data1_cc$local_rate_punish_cat6==1,]
data1_p_cat2 = data1_cc[data1_cc$local_rate_punish_cat6==2,]
data1_p_cat3 = data1_cc[data1_cc$local_rate_punish_cat6==3,]
data1_p_cat4 = data1_cc[data1_cc$local_rate_punish_cat6==4,]
data1_p_cat5 = data1_cc[data1_cc$local_rate_punish_cat6==5,]
data1_p_cat6 = data1_cc[data1_cc$local_rate_punish_cat6==6,]

data_risk <- data.table(Risk_category=c(1:6), Risk = 0,
                        LL = 0, UL = 0,
                        Label = c("[0,5]", "(5, 10]", "(10, 15]",
                                  "(15, 20]", "(20, 25]", "(25, 100]"),
                        Obs = 0)
for (i in 1:6) {
  # tmp_lm <- lm(behavior_punish ~ 1, data = eval(rlang::parse_expr(paste0("data1_p_cat",1))))
  tmp_lm <- lm(behavior_punish ~ 1, data = eval(rlang::parse_expr(paste0("data1_p_cat",i))))
  
  data_risk[i, Risk:= tmp_lm$coefficients]
  data_risk[i, LL:= tmp_lm$coefficients - coef(summary(tmp_lm))[, "Std. Error"]]
  data_risk[i, UL:= tmp_lm$coefficients + coef(summary(tmp_lm))[, "Std. Error"]]
  data_risk[i, Obs:= nrow(eval(rlang::parse_expr(paste0("data1_p_cat",i))))]
}
data_risk

data1_cc %>%
  filter(conflict == 0) %>%
  group_by(behavior) %>%
  summarize(n = n()) %>%
  mutate(prevalence = n / sum(n))

binom.confint(x = 297, n = 3098+2598+297)

data1_cc %>%
  filter(conflict == 1) %>%
  group_by(behavior) %>%
  summarize(n = n()) %>%
  mutate(prevalence = n / sum(n))

binom.confint(x=77, n=296+552+77)
```

```{r}
# Create data for the individual dots
data_fracs = data1_cc %>% 
  dplyr::select(local_rate_punish_lag) %>%
  mutate(value = round(local_rate_punish_lag, 4)) %>%
  select(value) %>%
  table() %>%
  as_tibble()

data_fracs = data_fracs %>%
  mutate(Risk_category = case_when(value <= 0.05 ~ 1,
                                   value > 0.05 & value <= 0.1 ~ 2,
                                   value > 0.1 & value <= 0.15 ~ 3,
                                   value > 0.15 & value <= 0.2 ~ 4,
                                   value > 0.2 & value <= 0.25 ~ 5,
                                   value > 0.25 ~ 6))
```

```{r}
#box plot
ggplot(
  data=data_risk,
  aes(x = Risk_category, y = Risk*100, 
      ymin = LL*100, ymax = UL*100)) +
  geom_bar(data=data_risk,
           stat = "identity",alpha= 0.5) +
  geom_errorbar(aes(ymin = LL*100, ymax = UL*100), width=0, cex = 0.7) +
  # geom_point(aes(x = 1:6, y = 0.5))+
  theme_classic() +
  ylab("Probability of ego \npunishment behavior (%)") +
  scale_y_continuous(breaks=seq(0,20,by=2.5)) +
  xlab('\nPrevalence of punishment among alters \nin the previous round (%)') +
  scale_x_discrete(limits=c("[0,5]\n\n 5251", "(5, 10]\n\n 219", "(10, 15]\n\n 523",
                            "(15, 20]\n\n 440", "(20, 25]\n\n 212", "(25, 100]\n\n 273")) + 
  theme(legend.position= "none",
        panel.grid.minor.x = element_blank(),
        axis.title = element_text(size = 18),
        axis.text = element_text(size = 15),
        strip.text = element_text(face = "bold", size = rel(1.5)),
        strip.background = element_blank())
# ggsave(paste0(path_to_figures, "punish_rate.png"),
#        plot = fig_risk, width = 20, height = 12, units = "cm")
#        
```

# Statistical analyses

## Statistical test for differences in decision times

```{r}
## Two sample Kolmogorov test for difference in DT distributions comparing above and below threshold

times_below_thresh = data1_cc %>% filter(conflict == 0) %>% select(behaviorTime_sec) %>% pull()
times_above_thresh = data1_cc %>% filter(conflict == 1) %>% select(behaviorTime_sec) %>% pull()

ks.test(times_above_thresh, times_below_thresh)

## Use the alternate definition of threshold: 0: 0-15%, 1: 15%
data1_cc_alt = data1_cc %>%
  mutate(conflict2 = ifelse(local_rate_punish_lag <= 0.15, 0, 1)) 

times_below_thresh = data1_cc_alt %>% filter(conflict2 == 0) %>% select(behaviorTime_sec) %>% pull()
times_above_thresh = data1_cc_alt %>% filter(conflict2 == 1) %>% select(behaviorTime_sec) %>% pull()

ks.test(times_above_thresh, times_below_thresh)
t.test(times_above_thresh, times_below_thresh)
wilcox.test(times_above_thresh, times_below_thresh)
```

## Bivariate analyses for Results section

```{r}
# Cooperation in the prior round
data_coop_prev = data1_cc %>% 
  filter(behavior_coop_lag == 1) %>%
  group_by(behavior) %>%
  summarize(n = n()) %>%
  mutate(prevalence = n / sum(n))

data_def_prev = data1_cc %>% 
  filter(behavior_defect_lag == 1) %>%
  group_by(behavior) %>%
  summarize(n = n()) %>%
  mutate(prevalence = n / sum(n))

data_punish_prev = data1_cc %>% 
  filter(behavior_punish_lag == 1) %>%
  group_by(behavior) %>%
  summarize(n = n()) %>%
  mutate(prevalence = n / sum(n))

data_nocoop_prev = data1_cc %>% 
  filter(behavior_coop_lag == 0) %>%
  group_by(behavior) %>%
  summarize(n = n()) %>%
  mutate(prevalence = n / sum(n))

binom.confint(data_coop_prev %>% 
                filter(behavior == "P") %>% 
                select(n) %>% pull(),
              sum(data_coop_prev$n))

binom.confint(data_def_prev %>%
                filter(behavior == "P") %>%
                select(n) %>% pull(),
              sum(data_def_prev$n))

binom.confint(data_punish_prev %>%
                filter(behavior == "P") %>%
                select(n) %>% pull(),
              sum(data_punish_prev$n))

binom.confint(data_nocoop_prev %>%
                filter(behavior == "P") %>%
                select(n) %>% pull(),
              sum(data_nocoop_prev$n))
```

```{r}
# Cooperation rate in prior round
data_sum_low_coop = data1_cc %>% 
  filter(local_rate_coop_lag < 0.5) %>%
  group_by(behavior) %>%
  summarize(n = n()) %>%
  mutate(prevalence = n / sum(n))

data_sum_high_coop = data1_cc %>% 
  filter(local_rate_coop_lag >= 0.5) %>%
  group_by(behavior) %>%
  summarize(n = n()) %>%
  mutate(prevalence = n / sum(n))

binom.confint(data_sum_low_coop %>% 
                filter(behavior == "P") %>% 
                select(n) %>% pull(),
              sum(data_sum_low_coop$n))

binom.confint(data_sum_high_coop %>% 
                filter(behavior == "P") %>% 
                select(n) %>% pull(),
              sum(data_sum_high_coop$n))
```

```{r}
# Cumulative payoff
data_lowPayoff = data1_cc %>% 
  filter(round == 15, cumulativePayoff < median(cumulativePayoff)) %>%
  group_by(behavior) %>%
  summarize(n = n()) %>%
  mutate(prevalence = n / sum(n))


binom.confint(data_lowPayoff %>% 
                filter(behavior == "P") %>% 
                select(n) %>% pull(),
              sum(data_lowPayoff$n))

data_highPayoff = data1_cc %>% 
  filter(cumulativePayoff >= median(cumulativePayoff)) %>%
  group_by(behavior) %>%
  summarize(n = n()) %>%
  mutate(prevalence = n / sum(n))

binom.confint(data_highPayoff %>% 
                filter(behavior == "P") %>% 
                select(n) %>% pull(),
              sum(data_highPayoff$n))


```

```{r}
# Punish rate in prior round (ns)
data_sum_low_punish = data1_cc %>% 
  filter(local_rate_punish_lag < 0.5) %>%
  group_by(behavior) %>%
  summarize(n = n()) %>%
  mutate(prevalence = n / sum(n))

data_sum_high_punish = data1_cc %>% 
  filter(local_rate_punish_lag >= 0.5) %>%
  group_by(behavior) %>%
  summarize(n = n()) %>%
  mutate(prevalence = n / sum(n))   

binom.confint(data_sum_low_punish %>% 
                filter(behavior == "P") %>% 
                select(n) %>% pull(),
              sum(data_sum_low_punish$n))

binom.confint(data_sum_high_punish %>% 
                filter(behavior == "P") %>% 
                select(n) %>% pull(),
              sum(data_sum_high_punish$n))

# Punish in previous round
data_prev_punish = data1_cc %>% 
  filter(behavior_punish_lag == 1) %>%
  group_by(behavior) %>%
  summarize(n = n()) %>%
  mutate(prevalence = n / sum(n))
binom.confint(data_prev_punish %>% 
                filter(behavior == "P") %>% 
                select(n) %>% pull(),
              sum(data_prev_punish$n))

data_prev_nonpunish = data1_cc %>% 
  filter(behavior_punish_lag == 0) %>%
  group_by(behavior) %>%
  summarize(n = n()) %>%
  mutate(prevalence = n / sum(n))
binom.confint(data_prev_nonpunish %>% 
                filter(behavior == "P") %>% 
                select(n) %>% pull(),
              sum(data_prev_nonpunish$n))


```

## Stratified analysis: Individual Peace by Alter Punishing, Decision Time by Punishment Type

- Individual peace (PART 1): From the main text - individual peace is defined by not punishing and having
no punishing alters in a single round. We stratify individual peace status by alter punish status
- Spontaneous vs. rational punishment (PART 2): We define two types of punishment: spontaneous - not triggered by punishment in local network vs. rational - in response to punishment in local network

```{r}
# PART 1
# Regenerate the individual peace status
data1 = data1 %>%
  mutate(peace_individual = ifelse(local_rate_punish_lag == 0 & 
                                     behavior_punish_lag == 0, 1, 0))


# Create the list of alters by superid
ndata_alters_list = ndata1 %>% 
  select(round, game, starts_with("id")) %>%
  filter(round != 0) %>%
  mutate(across(starts_with("id"), ~100*game+parse_number(.))) %>%
  rename(superid = id)

names(ndata_alters_list)[4:20] = c("alter1", "alter2", "alter3", "alter4", 
                                   "alter5", "alter6", "alter7", "alter8",
                                   "alter9", "alter10", "alter11", "alter12",
                                   "alter13", "alter14", "alter15", "alter16",
                                   "alter17")

ndata_alters_lag = ndata_alters_list
names(ndata_alters_lag)[4:20] = paste0("lag_",names(ndata_alters_lag)[4:20])
ndata_alters_lag$round = ndata_alters_lag$round+1

ndata_alters = merge(ndata_alters_list, ndata_alters_lag, 
                     by = c("superid", "round", "game")) %>%
  arrange(superid, round)

behaviors = data1 %>% 
  filter(round != 0) %>%
  select(superid, game, round, behavior_coop_lag, 
         behavior_punish_lag, behavior_defect_lag)

ndata_long_alters = ndata_alters %>%
  select(superid, round, game, starts_with("lag")) %>%
  pivot_longer(cols = starts_with("lag"), values_to = "alter_id") %>%
  filter(is.na(alter_id) == F)

pi_status = data1 %>% 
  select(superid, game, round, peace_individual, behavior_punish_lag)

punish_lag_status = data1 %>%
  select(superid, game, round, behavior_punish)

tdata_merged = ndata_long_alters %>%
  left_join(pi_status, by = c("superid", "round", "game")) %>%
  mutate(prev_round = round - 1) %>%
  left_join(punish_lag_status, 
            by = c("alter_id" = "superid", "game", "prev_round" = "round")) %>%
  rename(alter_punish_lag = behavior_punish)

tdata1 = tdata_merged %>%
  group_by(superid, round, game) %>%
  summarize(alter_punish_count = sum(alter_punish_lag)) %>%
  mutate(alter_punish_flag = ifelse(alter_punish_count == 0, 0, 1)) %>%
  left_join(pi_status, by = c("superid", "game", "round"))

xtabs(~peace_individual + behavior_punish_lag + alter_punish_flag, tdata1)

xtabs(~behavior_punish_lag + peace_individual, data1) # no punishers in prev round are in peace

round(addmargins(prop.table(xtabs(~behavior_punish_lag + peace_individual + alter_punish_flag, tdata1))), 3)

xtabs(~behavior_punish_lag + peace_individual + alter_punish_flag, tdata1)
round(addmargins(prop.table(xtabs(~behavior_punish_lag + peace_individual + alter_punish_flag, tdata1))), 3)

round(addmargins(prop.table(xtabs(~behavior_punish_lag + peace_individual + alter_punish_flag, tdata1), c(3, 1))), 3)
```


Based on above, we see that (280 decisions) 4.2% of those who did not punish previously and had no punishing alters did not end up in peace in the following round. Conversely, 5.6% of people who did not punish previously but had punishing neighbors did end up in peace.  
 
This suggests possible transport of punishing from new members of the social network, or spontaneous start of punishment by either new or old members. The 104 instances of alter punishment + ego no punishment suggests people may excise punishers from their network to establish peace at a low rate.
 
```{r}
# PART 2
# by definition, all round 1 P must be spontaneous (because no alter information is available)

# First, stratify punishment by presence of punishing alters

data1 %>% 
  as_tibble() %>% 
  filter(behavior_punish == 1) %>%
  mutate(spontaneous_p = ifelse(behavior_punish == 1 & local_rate_punish_lag == 0, 1, 0)) %>%
  summarize(perc_spontaneous = mean1(spontaneous_p)) #70% of punishment was spontaneous

# so yes, there is less rational punishment

data1 %>% 
  as_tibble() %>% 
  filter(behavior_punish == 1) %>%
  mutate(spontaneous_p = case_when(round == 1 & behavior_punish == 1 ~ 1,
                                   round != 1 & behavior_punish == 1 & local_rate_punish_lag == 0 ~ 1,
                                   round != 1 & behavior_punish == 1 & local_rate_punish_lag != 0 ~ 0,
                                   round != 1 & behavior_punish == 1 & is.na(local_rate_punish_lag) == 1 ~ 1),
         behaviorTime_sec = behaviorTime/1000) %>%
  group_by(spontaneous_p) %>%
  summarize(mean_decision_time = mean1(behaviorTime_sec))

data1_stratified_p = data1 %>% 
  as_tibble() %>% 
  filter(behavior_punish == 1) %>%
  mutate(spontaneous_p = case_when(round == 1 & behavior_punish == 1 ~ 1,
                                   round != 1 & behavior_punish == 1 & local_rate_punish_lag == 0 ~ 1,
                                   round != 1 & behavior_punish == 1 & local_rate_punish_lag != 0 ~ 0,
                                   round != 1 & behavior_punish == 1 & is.na(local_rate_punish_lag) == 1 ~ 1),
         behaviorTime_sec = behaviorTime/1000) 

spontaneous_p_times = data1_stratified_p %>% filter(spontaneous_p == 1) %>% select(behaviorTime_sec) %>% pull()
rational_p_times = data1_stratified_p %>% filter(spontaneous_p == 0) %>% select(behaviorTime_sec) %>% pull()

t.test(spontaneous_p_times, rational_p_times) # p = 0.03737

# spontaneous p is slower

data1 %>% 
  as_tibble() %>% 
  filter(round != 1, behavior_punish == 1) %>%
  mutate(spontaneous_p = case_when) %>%
  filter(is.na(spontaneous_p) == T) %>%
  select(superid, round, game, behavior_punish, local_rate_punish_lag, spontaneous_p)

# which behavior is fastest when the local environment is cooperative? which behavior is fastest when the local environment is punishing?

data1 %>%
  filter(local_rate_punish_lag > 0) %>%
  mutate(behavior = case_when(behavior_coop == 1 ~ "C",
                              behavior_defect == 1 ~ "D",
                              behavior_punish == 1 ~ "P"),
         behaviorTime_sec = behaviorTime/1000) %>%
  group_by(behavior) %>%
  filter(is.na(behavior) == F) %>%
  summarize(mean_decision_time = mean1(behaviorTime_sec))
# both C+D are slower than P

# is cooperation fastest when cooperation is dominant?
data1 %>%
  filter(local_rate_coop_lag > 0.1) %>%
  mutate(behavior = case_when(behavior_coop == 1 ~ "C",
                              behavior_defect == 1 ~ "D",
                              behavior_punish == 1 ~ "P"),
         behaviorTime_sec = behaviorTime/1000) %>%
  group_by(behavior) %>%
  filter(is.na(behavior) == F) %>%
  summarize(mean_decision_time = mean1(behaviorTime_sec))
# coop is faster when cooperation is more available, punishment is even slower
```

## Analysis of time pressure experiment data

```{r}
load("~/Documents/Projects/breadboard/time_pressure_brb/data/for analysis/mdata3.Rdata")

tpdata = as_tibble(mdata3)

# Renaming current rates
tpdata = tpdata %>% rename(local_rate_coop = cur_local_rate_coop, 
                               local_rate_defect = cur_local_rate_defect,
                               local_rate_punish = cur_local_rate_punish)

# Create continuous happiness variable
tpdata$happ = ifelse(tpdata$satisfaction == "v_good", 2, 
                       ifelse(tpdata$satisfaction == "good", 1, 
                              ifelse(tpdata$satisfaction == "neutral", 0,
                                     ifelse(tpdata$satisfaction == "bad", -1, 
                                            ifelse(tpdata$satisfaction == "v_bad", -2, NA)))))

# Create positive wealth variable
tpdata$PosWealth = ifelse(tpdata$cumulativePayoff >= 0, 
                            tpdata$cumulativePayoff, 0)

# Create categorical WealthLevel (5 levels)
tpdata = tpdata %>%
  mutate(WealthLevel = case_when(cPayoffS < -1.5 ~ "Poorest",
                                 cPayoffS >= -1.5 & cPayoffS < -0.5  ~ "Poorer",
                                 cPayoffS >= -0.5 & cPayoffS < 0.5  ~ "Middle",
                                 cPayoffS >= 0.5 & cPayoffS < 1.5  ~ "Richer",
                                 cPayoffS >= 1.5  ~ "Richest"))

# Create wealth visibility
tpdata$showScore = ifelse(tpdata$showScore=="true",1,0)

# Matching names over the two data
tpdata = tpdata[,!(names(tpdata) == "gameNumber")]

# Other variables
tpdata$age = as.numeric(unlist(tpdata$age))
tpdata$gender = as.character(unlist(tpdata$gender))
tpdata$ipAddress = as.character(unlist(tpdata$ipAddress))
# Convert IPaddress to country
library(rgeolocate)
file = system.file("extdata","GeoLite2-Country.mmdb", package = "rgeolocate")
ipCountries = maxmind(tpdata$ipAddress, file, "country_name")
tpdata$country = ipCountries$country_name

# Convert country to categorical
`%notin%` <- Negate(`%in%`)

tpdata = tpdata %>% 
   mutate(country_3cat = factor(case_when(country == "United States" ~ "US",
                                       country == "India" ~ "India",
                                       country %notin% c("United States", "India") ~ "Other"),
                             levels = c("US", "India", "Other")))
tpdata %>%
  group_by(country) %>%
  filter(round == 1) %>%
  select(country) %>%
  summarize(n=n()) %>%
  mutate(perc = n/sum(n))

tpdata %>%
  group_by(gender) %>%
  filter(round == 1) %>%
  select(gender) %>%
  summarize(n = n()) # more males than females, same as before

tpdata %>%
  filter(round == 1) %>%
  summarize(mean_age = mean1(age)) #36.7 - same as before

tpdata %>%
  group_by(tp_on) %>%
  summarize(mean_dt = mean1(behaviorTime))

tpdata %>%
  group_by(tp_on, behavior) %>%
  filter(behavior %in% c("C", "D", "P")) %>%
  summarize(mean_dt = mean1(behaviorTime),
            median_dt = median1(behaviorTime))

tpdata %>%
  group_by(behavior, tp_on) %>%
  filter(tp_on == 0) %>%
  filter(behavior %in% c("C", "D", "P")) %>%
  summarize(n = n()) %>%
  ungroup(behavior) %>%
  mutate(prev = n/sum(n)) %>%
  bind_rows(tpdata %>%
  group_by(behavior, tp_on) %>%
  filter(tp_on == 1) %>%
  filter(behavior %in% c("C", "D", "P")) %>%
  summarize(n = n()) %>%
  ungroup(behavior) %>%
  mutate(prev = n/sum(n)))

tpdata = tpdata %>%
  mutate(behavior_punish = ifelse(behavior == "P", 1, 0),
         behavior_coop = ifelse(behavior == "C", 1, 0),
         behavior_defect = ifelse(behavior == "D", 1, 0))

tp1 = glmer(behavior_punish ~ tp_on + factor(round) + (1|game) + (1|superid), data = tpdata, family = binomial, nAGQ=0, control = glmerControl(optimizer = c("bobyqa"), optCtrl=list(maxfun=2e5), calc.derivs=FALSE))
se = sqrt(diag(vcov(tp1)))
# table of estimates with 95% CI
tab_tp1 = cbind(Est = fixef(tp1), LL = fixef(tp1) - 1.96 * se, UL = fixef(tp1) + 1.96 * se)
round(exp(tab_tp1), digits = 3)[1:2,]
summary(tp1)
```

## Classifying punishment into subtypes

We classify punishment into 3 main subtypes:

- inequality aversion: punishment to reduce perceived inequality
  - 3rd party punishment is a subclass of this: punishment to promote cooperation that is not reactive
- reactive: punishment in response to other punishment
- unexplained: punishment that is neither reactive nor inequality aversion

### Experiment 1 data

```{r}
# 4 main datasets: 
# harmdata - cleaned raw individual-level data 
# ldata4 - tie component of network-level data
# ndata1 - node component of network-level data
# data1 - main aggregated dataset including lag (rounds t-1, t-2, etc.) data

data1 = data1 %>%
  as_tibble()

dim(data1 %>% filter(behavior_punish == 1)) #562 punishments
```

#### Punishment for inequality aversion 

We define this subtype of punishment as punishment that occurs when the wealth of the ego is less than the average wealth of alters.

```{r, message = F, warning = F}
# first, get the list of alters
ndata_alters_list = ndata1 %>% 
  select(round, game, starts_with("id")) %>%
  filter(round != 0) %>%
  mutate(across(starts_with("id"), ~100*game+parse_number(.))) %>%
  rename(superid = id)

names(ndata_alters_list)[4:20] = c("alter1", "alter2", "alter3", "alter4", 
                                   "alter5", "alter6", "alter7", "alter8",
                                   "alter9", "alter10", "alter11", "alter12",
                                   "alter13", "alter14", "alter15", "alter16",
                                   "alter17")

current_wealth = data1 %>% 
  filter(round != 0) %>%
  select(superid, game, round, cumulativePayoff, cPayoffS)

ndata_long_alters = ndata_alters_list %>%
  pivot_longer(cols = starts_with("alter"), values_to = ("alter_id")) %>%
  filter(is.na(alter_id) == 0)

ndata_long_alters_wealth = ndata_long_alters %>%
  left_join(current_wealth, by = c("round", "game", "alter_id" = "superid")) %>%
  group_by(superid, round, game) %>%
  summarize(mean_alter_wealth = mean1(cPayoffS))

data1_pc = data1 %>%
  left_join(ndata_long_alters_wealth, by = c("round", "game", "superid")) %>%
  mutate(wealth_inequal = ifelse(cPayoffS < mean_alter_wealth, 1, 0)) 
  
data1_pc %>%
  filter(behavior_punish == 1, round > 0) %>%
  group_by(wealth_inequal) %>%
  summarize(n = n()) %>%
  mutate(perc = n/sum(n)) %>%
  filter(is.na(wealth_inequal) == 0)

prop.test(x = c(270, 279), n = c(549, 549))
```

**49.6% wealth inequality vs 48% not due to wealth inequality**

#### Reactive punishment

Punishment in response to punishment, defined as punishment after an alter punished in last round regardless of punishing alters' current ties (so this means the punishing alter no longer needs to be tied to the ego after rewiring).

```{r}
data1_pc = 
  data1_pc %>% 
  mutate(reactive_p = ifelse(behavior_punish == 1 & local_rate_punish_lag !=0, 1, 0))

data1_pc %>%
  filter(behavior_punish == 1) %>%
  mutate(reactive_p = ifelse(local_rate_punish_lag !=0, 1, 0)) %>%
  group_by(reactive_p) %>%
  summarize(n = n()) %>%
  mutate(perc = n/sum(n)) %>%
  filter(is.na(reactive_p) == 0)

prop.test(x = c(359, 149), n = c(508, 508))
```

**26.5% reactive, 63.9% not (54 NAs)**

#### Unexplained punishments

Punishment that is not reactive or calculated.

```{r}
data1_pc_punishes = data1_pc %>%
  filter(behavior_punish == 1)

data1_pc_punishes %>%
  filter(round <= 1) #49

data1_pc_punishes %>%
  filter(round > 1 & wealth_inequal == 0 & reactive_p == 0) #171

# Cross tab
xtabs(~reactive_p + wealth_inequal, data1_pc_punishes)
```
#### Calculating distribution of decision time by punishment status

##### Inequality aversion

```{r}
# Statistics
data1_pc %>%
  mutate(behaviorTime_sec = behaviorTime/1000) %>%
  group_by(wealth_inequal) %>%
  filter(is.na(wealth_inequal) == F) %>%
  summarize(mean_dt = mean1(behaviorTime_sec),
            median_dt = median1(behaviorTime_sec),
            max_dt = max(behaviorTime_sec, na.rm = T),
            min_dt = min(behaviorTime_sec, na.rm = T),
            range_dt = range(behaviorTime_sec, na.rm = T))
```

```{r}
# Visual
pun1 = data1_pc %>%
  mutate(behaviorTime_sec = behaviorTime/1000) %>%
  na.omit() %>%
  filter(wealth_inequal %in% 0:1) %>%
  ggplot(aes(x = behaviorTime_sec, color = as.factor(wealth_inequal))) +
  geom_density(adjust = 2) + 
  scale_x_log10(limits = c(1, 110),breaks = c(1, 10, 100)) +
  scale_y_continuous(limits = c(0, 1.3)) +
  scale_color_manual(labels = c("Inequality Aversion", "Other"),
                     values = c("orange", "skyblue2")) +
    theme(axis.title = element_blank(),
        axis.text = element_text(size = rel(1.3)),
        legend.position = "right") +
  guides(colour=guide_legend(title = NULL))
```   
##### Reactive punishment

```{r}
# Statistics
data1_pc %>%
  mutate(behaviorTime_sec = behaviorTime/1000) %>%
  group_by(reactive_p) %>%
  filter(is.na(reactive_p) == F) %>%
  summarize(mean_dt = mean1(behaviorTime_sec),
            median_dt = median1(behaviorTime_sec),
            max_dt = max(behaviorTime_sec, na.rm = T),
            min_dt = min(behaviorTime_sec, na.rm = T),
            range_dt = range(behaviorTime_sec, na.rm = T))
```

```{r}
# Visual
pun2 = data1_pc %>%
  mutate(behaviorTime_sec = behaviorTime/1000) %>%
  na.omit() %>%
  filter(reactive_p %in% 0:1) %>%
  ggplot(aes(x = behaviorTime_sec, color = as.factor(reactive_p))) +
  geom_density(adjust = 2) + 
  scale_x_log10(limits = c(1, 110),breaks = c(1, 10, 100)) +
  scale_y_continuous(limits = c(0, 1.3)) +
  scale_color_manual(labels = c("Reactive Punishment", "Other"),
                     values = c("magenta", "skyblue2")) +  
  theme(axis.title = element_blank(),
        axis.text = element_text(size = rel(1.3)),
        legend.position = "right") +
  guides(colour=guide_legend(title = NULL))
```   

##### Unexplained punishment

```{r}
# Visual
pun3 = data1_pc %>%
  mutate(behaviorTime_sec = behaviorTime/1000,
         unexplained_p = ifelse(behavior_punish == 1 & reactive_p == 0 & wealth_inequal == 0, 1, 0)) %>%
  na.omit() %>%
  filter(unexplained_p %in% 0:1) %>%
  ggplot(aes(x = behaviorTime_sec, color = as.factor(unexplained_p))) +
  geom_density(adjust = 2) + 
  scale_x_log10(limits = c(1, 110),breaks = c(1, 10, 100)) +
  scale_y_continuous(limits = c(0, 1.3)) +
  scale_color_manual(labels = c("Unexplained Punishment", "Other"),
                     values = c("darkgreen", "skyblue2")) +
    theme(axis.title = element_blank(),
        axis.text = element_text(size = rel(1.3)),
        legend.position = "right") +
  guides(colour=guide_legend(title = NULL))
```   

#### Combined figure

```{r}
# Create a 4-level variable: 1 = IA, 2 = Reactive, 3 = Unexpl., 4 = Other
data1_pc = data1_pc %>%
  mutate(
    behaviorTime_sec = behaviorTime/1000,
    unexplained_p = ifelse(behavior_punish == 1 & reactive_p == 0 & 
                             wealth_inequal == 0, 1, 0),
    pun_type = case_when(behavior_punish == 1 & wealth_inequal == 1 ~ 1,
                         behavior_punish == 1 & reactive_p == 1 ~ 2,
                         behavior_punish == 1 & unexplained_p == 1 ~ 3,
                         TRUE ~ 4))

# save the final data_pc
# save(data1_pc, file = "~/Documents/Projects/harming_esn/code/exp1/data1_pc.Rdata")

# Combined fig. - exp 1
data1_pc %>% 
  na.omit() %>%
  ggplot(aes(x = behaviorTime_sec, color = as.factor(pun_type))) +
  geom_density(adjust = 2) + 
  scale_x_log10(limits = c(1, 110),breaks = c(1, 10, 100)) +
  scale_y_continuous(limits = c(0, 1.3)) +
  scale_color_manual(labels = c("IA", "RP", "UP", "Other"),
                     values = c("#FFBF00", "#DE1A1A", "#29BF12", "#00A5CF")) +
    theme(
        axis.text = element_text(size = rel(1.3)),
        legend.position = "right") +
  guides(colour=guide_legend(title = NULL))+
  xlab("Decision Time (s)") +
  ylab("Density") + 
  ggtitle("Distribution of decision times by punishment subtype - Exp. 1")
```

### Experiment 2 data

```{r}
load("~/Documents/Projects/harming_esn/data/exp2/ndata1_tp.Rdata")
load("~/Documents/Projects/harming_esn/data/exp2/ldata4_tp.Rdata")
load("~/Documents/Projects/harming_esn/data/exp2/tpdata.Rdata")

tpdata = tpdata %>%
  as_tibble()

tpdata %>%
  filter(behavior == "P") %>%
  dim() #612 punishments
```

#### Instrumental punishment: punishing to reduce inequality defined as punishment that occurs when ego's wealth is lower than the mean wealth of alters

```{r}
# first, get the list of alters
ndata_alters_list = ndata_tp %>% 
  select(round, game, starts_with("id")) %>%
  filter(round != 0) %>%
  mutate(across(starts_with("id"), ~100*game+parse_number(.))) %>%
  rename(superid = id)

length(names(ndata_alters_list))

names(ndata_alters_list)[4:17] = c("alter1", "alter2", "alter3", "alter4", 
                                   "alter5", "alter6", "alter7", "alter8",
                                   "alter9", "alter10", "alter11", "alter12",
                                   "alter13", "alter14")

current_wealth = tpdata %>% 
  filter(round != 0) %>%
  select(superid, game, round, cumulativePayoff, cPayoffS)

ndata_long_alters = ndata_alters_list %>%
  pivot_longer(cols = starts_with("alter"), values_to = ("alter_id")) %>%
  filter(is.na(alter_id) == 0)

ndata_long_alters_wealth = ndata_long_alters %>%
  left_join(current_wealth, by = c("round", "game", "alter_id" = "superid")) %>%
  group_by(superid, round, game) %>%
  summarize(mean_alter_wealth = mean1(cPayoffS))

tpdata_pc = tpdata %>%
  left_join(ndata_long_alters_wealth, by = c("round", "game", "superid")) %>%
  mutate(wealth_inequal = ifelse(cPayoffS < mean_alter_wealth, 1, 0)) 

tpdata_pc %>%
  filter(behavior=="P", round > 0,is.na(wealth_inequal) == 0) %>%
  group_by(wealth_inequal) %>%
  summarize(n = n()) %>%
  mutate(perc = n/sum(n))

# checking p-value
prop.test(x = c(290, 312), n = c(290+312,  290+312))
```

**51.0% wealth inequality, 47.4% wealth equal**

#### Reactive punishment: punishment in response to punishment defined as: punishment after an alter punished in last round

```{r}
tpdata_pc = 
  tpdata_pc %>% 
  mutate(reactive_p = ifelse(behavior == "P" & prev_local_rate_punish!=0, 1, 0))

tpdata_pc %>%
  filter(behavior == "P") %>%
  group_by(reactive_p) %>%
  summarize(n = n()) %>%
  mutate(perc = n/sum(n))

prop.test(c(310, 302), c(612, 612))
```
**49.3% reactive, 50.7% not**

```{r}
# 3rd party punishment - i.e.; reactive_p = 0 + wealth_inequal = 1

tpdata_pc %>%
  filter(behavior == "P") %>%
  group_by(reactive_p, wealth_inequal) %>%
  summarize(n= n()) %>%
  filter(is.na(wealth_inequal) == 0) %>%
  ungroup() %>%
  mutate(perc = n/sum(n))

# 23.3%?
```


#### Unexplained punishments - not reactive or calculated

```{r}
tpdata_pc %>%
  filter(behavior == "P" & round <= 1) %>%
  dim()

tpdata_pc %>%
  filter(behavior == "P" & round > 1 & wealth_inequal == 0 & reactive_p == 0) %>%
  dim() 
```

```{r}
# crosstabs
xtabs(~wealth_inequal + reactive_p, tpdata_pc %>% filter(round > 1, behavior == "P"))
tpdata_pc %>%
  group_by(tp_on, behavior) %>%
  filter(behavior %in% c("C", "D", "P")) %>%
  summarize(n = n()) %>%
  mutate(perc = n/sum(n),
         total = sum(n))
```

```{r}
# p-values
# for C
prop.test(x = c(837, 706), n = c(1580, 1629)) # p < 0.0001

# for D
prop.test(x = c(379, 684), n = c(1580, 1629)) # p < 0.0001

# for P
prop.test(x = c(373, 239), n = c(1580, 1629)) # p < 0.0001
```

```{r}
tpdata_pc %>%
  group_by(tp_on, behavior, wealth_inequal) %>%
  filter(behavior %in% c("C", "D", "P"), is.na(wealth_inequal) == 0) %>%
  summarize(n = n()) %>%
  mutate(perc = n/sum(n),
         total = sum(n)) %>%
  filter(wealth_inequal == 1)

171/1580 # tp off
141/1629 # tp on

prop.test(c(171, 141), c(1580, 1629))
```

```{r}
tpdata_pc %>%
  group_by(tp_on, behavior, reactive_p) %>%
  filter(behavior %in% c("C", "D", "P"), is.na(reactive_p) == 0) %>%
  summarize(n = n()) %>%
  mutate(perc = n/sum(n),
         total = sum(n)) %>%
  filter(reactive_p == 1)

200/1580
102/1629

prop.test(c(200, 102), c(1580, 1629))
```

```{r}
tpdata_pc %>%
  group_by(tp_on, behavior, wealth_inequal, reactive_p) %>%
  filter(behavior %in% c("C", "D", "P"), is.na(wealth_inequal) == 0, is.na(reactive_p) == 0) %>%
  summarize(n = n()) %>%
  mutate(perc = n/sum(n),
         total = sum(n)) %>%
  filter(wealth_inequal == 0 & reactive_p == 0)

106/1580 #6.71
58/1629 #3.56

prop.test(c(106, 56), c(1580, 1629))
```

#### Distributions of decision time

#### Combined figure

```{r, message = F, warning = F}
# Create a 4-level variable: 1 = IA, 2 = Reactive, 3 = Unexpl., 4 = Other
# here, we need 2 datasets - one for TP on, one for TP off

tpdata_tpon = tpdata_pc %>%
  filter(tp_on == 1) %>%
  mutate(
    behaviorTime_sec = behaviorTime/1000,
    unexplained_p = ifelse(behavior == "P" & reactive_p == 0 & 
                             wealth_inequal == 0, 1, 0),
    pun_type = case_when(behavior == "P" & wealth_inequal == 1 ~ 1,
                         behavior == "P" & reactive_p == 1 ~ 2,
                         behavior == "P" & unexplained_p == 1 ~ 3,
                         TRUE ~ 4))

tpdata_tpoff = tpdata_pc %>%
  filter(tp_on == 0) %>%
  mutate(
    behaviorTime_sec = behaviorTime/1000,
    unexplained_p = ifelse(behavior == "P" & reactive_p == 0 & 
                             wealth_inequal == 0, 1, 0),
    pun_type = case_when(behavior == "P" & wealth_inequal == 1 ~ 1,
                         behavior == "P" & reactive_p == 1 ~ 2,
                         behavior == "P" & unexplained_p == 1 ~ 3,
                         TRUE ~ 4))

tpdata_pc = tpdata_pc %>% mutate(
    behaviorTime_sec = behaviorTime/1000,
    unexplained_p = ifelse(behavior == "P" & reactive_p == 0 & 
                             wealth_inequal == 0, 1, 0),
    pun_type = case_when(behavior == "P" & wealth_inequal == 1 ~ 1,
                         behavior == "P" & reactive_p == 1 ~ 2,
                         behavior == "P" & unexplained_p == 1 ~ 3,
                         TRUE ~ 4))


# save tpon and tpoff data
# save(tpdata_tpon, file = "~/Documents/Projects/harming_esn/code/exp2/tpdata_tpon.Rdata")
# save(tpdata_tpoff, file = "~/Documents/Projects/harming_esn/code/exp2/tpdata_tpoff.Rdata")
# save(tpdata_pc, file = "~/Documents/Projects/harming_esn/code/exp2/tpdata_pc.Rdata")

# Combined fig. - exp 2 (tp on)
tpdata_tpon %>% 
  na.omit() %>%
  ggplot(aes(x = behaviorTime_sec, color = as.factor(pun_type))) +
  geom_density(adjust = 2) + 
  scale_x_log10(limits = c(1, 110),breaks = c(1, 10, 100)) +
  scale_y_continuous(limits = c(0, 2)) +
  scale_color_manual(labels = c("IA", "RP", "UP", "Other"),
                     values = c("#FFBF00", "#DE1A1A", "#29BF12", "#00A5CF")) +
    theme(
        axis.text = element_text(size = rel(1.3)),
        legend.position = "right") +
  guides(colour=guide_legend(title = NULL))+
  xlab("Decision Time (s)") +
  ylab("Density") + 
  ggtitle("Distribution of decision times by punishment subtype - Exp. 2 (TP on)")

# Combined fig. - exp2 (tp off)
tpdata_tpoff %>% 
  na.omit() %>%
  ggplot(aes(x = behaviorTime_sec, color = as.factor(pun_type))) +
  geom_density(adjust = 2) + 
  scale_x_log10(limits = c(1, 110),breaks = c(1, 10, 100)) +
  scale_y_continuous(limits = c(0, 2)) +
  scale_color_manual(labels = c("IA", "RP", "UP", "Other"),
                     values = c("#FFBF00", "#DE1A1A", "#29BF12", "#00A5CF")) +
    theme(
        axis.text = element_text(size = rel(1.3)),
        legend.position = "right") +
  guides(colour=guide_legend(title = NULL))+
  xlab("Decision Time (s)") +
  ylab("Density") + 
  ggtitle("Distribution of decision times by punishment subtype - Exp. 2 (TP off)")
```
It looks like time pressure reduced punishment across the board - both sys1 and sys2 types of punishment were dramatically reduced.

### Punishment subtypes stratified by gender

# Regression Models (for SI)

We use logistic mixed effects models controlling for clustering by game and player and account for round by round variation by including an indicator variable for each individual game round.

The first set of models is based on data from Experiment 1. This set of models looks at the predictors of choosing punishment without the influence of time pressure.

The second set of models is based on data from Experiments 1 and 2. This set of models adjusts the outcome variable to each of the three subtypes of punishment (IA, RP, and UP).

## Model Set 1

### Model 1.1: Choosing punishment vs. wealth visibility

```{r}
m1.1 = glmer(behavior_punish ~ showScore + age + gender + behavior_coop_lag + local_rate_coop_lag + behavior_punish_lag + local_rate_punish_lag + cPayoffS_lag + degree_lag + happ_lag+ factor(round) + (1|game) + (1|superid), data = data1_cc, family = binomial, nAGQ=0, control = glmerControl(optimizer = c("bobyqa"), optCtrl=list(maxfun=2e5), calc.derivs=FALSE))
se = sqrt(diag(vcov(m1.1)))
# table of estimates with 95% CI
tab_m1.1 = cbind(Est = fixef(m1.1), LL = fixef(m1.1) - 1.96 * se, UL = fixef(m1.1) + 1.96 * se)
round(exp(tab_m1.1), digits = 3)[1:11,]
```

### Model 1.2: Choosing cooperation vs. wealth visibility

```{r}
m1.2 = glmer(behavior_coop ~ showScore + age + gender + behavior_coop_lag + local_rate_coop_lag + behavior_punish_lag + local_rate_punish_lag + cPayoffS_lag + degree_lag + happ_lag+ factor(round) + (1|game) + (1|superid), data = data1_cc, family = binomial, nAGQ=0, control = glmerControl(optimizer = c("bobyqa"), optCtrl=list(maxfun=2e5), calc.derivs=FALSE))
se = sqrt(diag(vcov(m1.2)))
# table of estimates with 95% CI
tab_m1.2 = cbind(Est = fixef(m1b), LL = fixef(m1b) - 1.96 * se, UL = fixef(m1b) + 1.96 * se)
round(exp(tab_m1.2), digits = 3)[1:11,]
```

### Model 1.3: Choosing defection vs. wealth visibility

```{r}
m1.3 = glmer(behavior_defect ~ showScore + age + gender + behavior_coop_lag + local_rate_defect_lag + behavior_defect_lag + local_rate_punish_lag + cPayoffS_lag + degree_lag + happ_lag+ factor(round) + (1|game) + (1|superid), data = data1_cc, family = binomial, nAGQ=0, control = glmerControl(optimizer = c("bobyqa"), optCtrl=list(maxfun=2e5), calc.derivs=FALSE))
se = sqrt(diag(vcov(m1.3)))
# table of estimates with 95% CI
tab_m1.3 = cbind(Est = fixef(m1.3), LL = fixef(m1.3) - 1.96 * se, UL = fixef(m1.3) + 1.96 * se)
round(exp(tab_m1.3), digits = 3)[1:11,]
```

### Model 2: Using categorical local punish rate from the prior round (checking for threshold)

```{r}
m2 = glmer(behavior_punish ~ showScore + age + gender + behavior_coop_lag + local_rate_coop_lag + behavior_punish_lag + factor(local_rate_punish_cat4) + cPayoffS_lag + degree_lag + happ + happ_lag + factor(round) + (1|game) + (1|superid), data = data1_cc, family = binomial, nAGQ=0, control = glmerControl(optimizer = c("bobyqa"), optCtrl=list(maxfun=2e5), calc.derivs=FALSE))
se = sqrt(diag(vcov(m2)))
# table of estimates with 95% CI
tab_m2= cbind(Est = fixef(m2), LL = fixef(m2) - 1.96 * se, UL = fixef(m2) + 1.96 * se)
round(exp(tab_m2), digits = 3)[1:16,]
```

### Model 3: Evaluating ego and alters' behavior 2 rounds prior

```{r}
m3 = glmer(behavior_punish ~ showScore + age + gender + behavior_coop_lag2 + local_rate_coop_lag2 + behavior_punish_lag2 + local_rate_punish_lag2 + cPayoffS_lag + degree_lag + happ_lag + happ_lag2 + factor(round) + (1|game) + (1|superid), data = data1_cc, family = binomial, nAGQ=0, control = glmerControl(optimizer = c("bobyqa"), optCtrl=list(maxfun=2e5), calc.derivs=FALSE))
se = sqrt(diag(vcov(m3)))
# table of estimates with 95% CI
tab_m3 = cbind(Est = fixef(m3), LL = fixef(m3) - 1.96 * se, UL = fixef(m3) + 1.96 * se)
round(exp(tab_m3), digits = 3)[1:16,]
```

### Model 4: Evaluating ego and alters' behavior 2 rounds prior, controlling for alter behavior 1 round prior

```{r}
m4 = glmer(behavior_punish ~ showScore + age + gender + behavior_coop_lag + behavior_coop_lag2 + local_rate_coop_lag + local_rate_coop_lag2 + +behavior_punish_lag + behavior_punish_lag2 + local_rate_punish_lag + local_rate_punish_lag2 + cPayoffS_lag + degree_lag + happ_lag + happ_lag2 + factor(round) + (1|game) + (1|superid), data = data1_cc, family = binomial, nAGQ=0, control = glmerControl(optimizer = c("bobyqa"), optCtrl=list(maxfun=2e5), calc.derivs=FALSE))
se = sqrt(diag(vcov(m4)))
# table of estimates with 95% CI
tab_m4 = cbind(Est = fixef(m4), LL = fixef(m4) - 1.96 * se, UL = fixef(m4) + 1.96 * se)
round(exp(tab_m4), digits = 3)[1:16,]
```

### Model 5: Punishment prevalence threshold vs. decision time

Models with "a" suffix use unscaled decision time as the outcome, while models with "b" suffix use log-transformed decision time as the outcome.

#### Model 5.1a: Punishment prevalence threshold vs. decision time

```{r}
# Conflict: indicator for the threshold
m5.1a = lmer(behaviorTime_sec ~ conflict + showScore + age + gender + cPayoffS_lag + degree_lag + happ_lag + factor(round) + (1|game) + (1|superid), data = data1_cc)
tab_model(m5.1a)
```

#### Model 5.1b: Punishment prevalence threshold vs. log decision time

```{r}
# Model 5e
m5.1b = lmer(log_behaviorTime ~ showScore + age + gender + cPayoffS_lag + degree_lag + happ_lag + conflict + factor(round) + (1|game) + (1|superid), data = data1_cc)
tab_model(m5.1b)
```

#### Model 5.2a: Punishment prevalence threshold and cooperation vs. decision time

```{r}
# Compare only cooperation vs punishment
data1_cc_no_defect = data1_cc %>% filter(behavior_defect == 0)
m5.2a = lmer(behaviorTime_sec ~ behavior_coop + showScore + age + gender + cPayoffS_lag + degree_lag + happ_lag + factor(round) + (1|game) + (1|superid), data = data1_cc_no_defect)
tab_model(m5.2a)
```

#### Model 5.2b: Punishment prevalence threshold and cooperation vs. log decision time

```{r}
m5.2b = lmer(log_behaviorTime ~ behavior_coop + showScore + age + gender + cPayoffS_lag + degree_lag + happ_lag + factor(round) + (1|game) + (1|superid), data = data1_cc_no_defect)
tab_model(m5.2b)
```

#### Model 5.3a: Punishment prevalence threshold and defection vs. decision time

```{r}
# Compare only defection vs punishment
data1_cc_no_coop = data1_cc %>% filter(behavior_coop == 0)
m5.3a = lmer(behaviorTime_sec ~ behavior_defect + showScore + age + gender + cPayoffS_lag + degree_lag + happ_lag + factor(round) + (1|game) + (1|superid), data = data1_cc_no_coop)
tab_model(m5.3a)
```

#### Model 5.3b: Punishment prevalence threshold and defection vs. log decision time

```{r}
# Model 5g
m5.3b = lmer(log_behaviorTime ~ behavior_defect + showScore + age + gender + cPayoffS_lag + degree_lag + happ_lag + factor(round) + (1|game) + (1|superid), data = data1_cc_no_coop)
tab_model(m5.3b)
```

#### Model 5.4a: Punishment prevalence threshold vs. decision time, comparing punishers and non-punishers (both C+D)

```{r}
m5.4a = lmer(behaviorTime_sec ~ behavior_punish + showScore + age + gender + cPayoffS_lag + degree_lag + happ_lag + factor(round) + (1|game) + (1|superid), data = data1_cc)
tab_model(m5.4a)
```

#### Model 5.4b: Punishment prevalence threshold vs. log decision time, comparing punishers and non-punishers (both C+D)

```{r}
## Model 5h
m5.4b = lmer(log_behaviorTime ~ behavior_punish + showScore + age + gender + cPayoffS_lag + degree_lag + happ_lag + factor(round) + (1|game) + (1|superid), data = data1_cc)
tab_model(m5.4b)
```

### Model 6: Restricting model 5 to only `conflict` == 1 or `conflict2` == 1

```{r}
# Model 6a
m6a = lmer(log_behaviorTime ~ behavior_coop + showScore + age + gender + cPayoffS_lag + degree_lag + happ_lag + factor(round) + (1|game) + (1|superid), data = data1_cc_no_defect[conflict == 1,])
tab_model(m6a)
```

```{r}
# Model 6b
m6b = lmer(log_behaviorTime ~ behavior_coop + showScore + age + gender + cPayoffS_lag + degree_lag + happ_lag + factor(round) + (1|game) + (1|superid), data = data1_cc_no_defect[conflict2 == 1,])
tab_model(m6b)
```

```{r}
# Model 6c
m6c = lmer(log_behaviorTime ~ behavior_defect + showScore + age + gender + cPayoffS_lag + degree_lag + happ_lag + factor(round) + (1|game) + (1|superid), data = data1_cc_no_coop[conflict == 1,])
tab_model(m56c)
```

```{r}
# Model 6d
m6d = lmer(log_behaviorTime ~ behavior_defect + showScore + age + gender + cPayoffS_lag + degree_lag + happ_lag + factor(round) + (1|game) + (1|superid), data = data1_cc_no_coop[conflict2 == 1,])
tab_model(m6d)
```

```{r}
## Model 6e
m6e = lmer(log_behaviorTime ~ behavior_punish + showScore + age + gender + cPayoffS_lag + degree_lag + happ_lag + factor(round) + (1|game) + (1|superid), data = data1_cc[conflict == 1,])
tab_model(m6e)
```

```{r}
## Model 6f
m6f = lmer(log_behaviorTime ~ behavior_punish + showScore + age + gender + cPayoffS_lag + degree_lag + happ_lag + factor(round) + (1|game) + (1|superid), data = data1_cc[conflict2 == 1,])
tab_model(m6f)
```

### Model 7: Repeating Model 6b, 6c, 6d with `conflict` == 0

```{r}
# Model 7a
m7a = lmer(log_behaviorTime ~ behavior_coop + showScore + age + gender + cPayoffS_lag + degree_lag + happ_lag + factor(round) + (1|game) + (1|superid), data = data1_cc_no_defect[conflict2 == 0,])
tab_model(m7a)
```

```{r}
# Model 7b
m7b = lmer(log_behaviorTime ~ behavior_defect + showScore + age + gender + cPayoffS_lag + degree_lag + happ_lag + factor(round) + (1|game) + (1|superid), data = data1_cc_no_coop[conflict2 == 0,])
tab_model(m7b)
```

```{r}
## Model 7c
m7c = lmer(log_behaviorTime ~ behavior_punish + showScore + age + gender + cPayoffS_lag + degree_lag + happ_lag + factor(round) + (1|game) + (1|superid), data = data1_cc[conflict2 == 0,])
tab_model(m7c)
```


# Model Set 2

### Model 8: Using Inequality Aversion as the Outcome

```{r}
m8a = glmer(wealth_inequal ~ showScore + age + gender + behavior_coop_lag + local_rate_coop_lag + behavior_punish_lag + local_rate_punish_lag + cPayoffS_lag + degree_lag + happ_lag+ factor(round) + (1|game) + (1|superid), data = data1_pc, family = binomial, nAGQ=0, control = glmerControl(optimizer = c("bobyqa"), optCtrl=list(maxfun=2e5), calc.derivs=FALSE))
se = sqrt(diag(vcov(m8a)))
# table of estimates with 95% CI
tab_m8a = cbind(Est = fixef(m8a), LL = fixef(m8a) - 1.96 * se, UL = fixef(m8a) + 1.96 * se)
round(exp(tab_m8a), digits = 3)[1:11,]

# output with p-values
tidy(m8a) %>%
  select(term, estimate, std.error, p.value) %>%
  rename(Term = term, Estimate = estimate, SE = std.error, p = p.value) %>%
  mutate(Estimate = round(Estimate, 4),
         SE = round(SE, 4),
         p = round(p, 4)) %>%
  head(11) %>%
  kbl() %>%
    kable_styling(bootstrap_options = c("striped", "hover", "condensed"))

```
### Model 9: Using Reactive Punishment as the Outcome

```{r}
m9 = glmer(reactive_p ~ showScore + age + gender + behavior_coop_lag + local_rate_coop_lag + behavior_punish_lag + local_rate_punish_lag + cPayoffS_lag + degree_lag + happ_lag+ factor(round) + (1|game) + (1|superid), data = data1_pc, family = binomial, nAGQ=0, control = glmerControl(optimizer = c("bobyqa"), optCtrl=list(maxfun=2e5), calc.derivs=FALSE))
se = sqrt(diag(vcov(m9)))
# table of estimates with 95% CI
tab_m9 = cbind(Est = fixef(m9), LL = fixef(m9) - 1.96 * se, UL = fixef(m9) + 1.96 * se)
round(exp(tab_m9), digits = 3)[1:11,]

# output with p-values
tidy(m9) %>%
  select(term, estimate, std.error, p.value) %>%
  rename(Term = term, Estimate = estimate, SE = std.error, p = p.value) %>%
  mutate(Estimate = round(Estimate, 4),
         SE = round(SE, 4),
         p = round(p, 4)) %>%
  head(11)  %>%
  kbl() %>%
    kable_styling(bootstrap_options = c("striped", "hover", "condensed"))
```

### Model 10: Using Unexplained Punishment as the Outcome

```{r}
m10 = glmer(reactive_p ~ showScore + age + gender + behavior_coop_lag + local_rate_coop_lag + behavior_punish_lag + local_rate_punish_lag + cPayoffS_lag + degree_lag + happ_lag+ factor(round) + (1|game) + (1|superid), data = data1_pc, family = binomial, nAGQ=0, control = glmerControl(optimizer = c("bobyqa"), optCtrl=list(maxfun=2e5), calc.derivs=FALSE))
se = sqrt(diag(vcov(m10)))
# table of estimates with 95% CI
tab_m10 = cbind(Est = fixef(m10), LL = fixef(m10) - 1.96 * se, UL = fixef(m10) + 1.96 * se)
round(exp(tab_m10), digits = 3)[1:11,]

# output with p-values
tidy(m10) %>%
  select(term, estimate, std.error, p.value) %>%
  rename(Term = term, Estimate = estimate, SE = std.error, p = p.value) %>%
  mutate(Estimate = round(Estimate, 4),
         SE = round(SE, 4),
         p = round(p, 4)) %>%
  head(11) %>%
  kbl() %>%
    kable_styling(bootstrap_options = c("striped", "hover", "condensed"))
```

## Model 11: Exp. 2: IA as outcome

```{r}
names(tpdata_pc)

tpdata_pc = tpdata_pc %>%
  mutate(behavior_punish = ifelse(behavior == "P" & is.na(behavior) == 0, 1, 0),
         behavior_coop = ifelse(behavior == "C" & is.na(behavior) == 0, 1, 0),
         behavior_defect = ifelse(behavior == "D" & is.na(behavior) == 0, 1, 0))%>%
  rename(local_rate_coop_lag = prev_local_rate_coop,
         local_rate_punish_lag = prev_local_rate_punish,
         local_rate_defect_lag = prev_local_rate_defect)

data_lag = tpdata_pc %>% select(superid, round, initial_score, payoff, 
                                    cumulativePayoff, cPayoffS, WealthLevel, 
                                    behavior_coop, local_rate_coop, 
                                    behavior_defect, local_rate_defect, 
                                    behavior_punish, local_rate_punish, 
                                  degree, happ, behaviorTime)
names(data_lag)[-c(1,2)] = paste0(names(data_lag)[-c(1,2)],"_lag")
data_lag$round = data_lag$round + 1
tpdata_pc= merge(x=tpdata_pc,y=data_lag,all.x=T,all.y=F,by=c("superid","round"))
names(tpdata_pc)
```

```{r}
m11 = glmer(reactive_p ~ tp_on + age + gender + behavior_coop_lag + local_rate_coop_lag + behavior_punish_lag + local_rate_punish_lag + cPayoffS_lag + degree_lag + happ_lag+ factor(round) + (1|game) + (1|superid), data = tpdata_pc, family = binomial, nAGQ=0, control = glmerControl(optimizer = c("bobyqa"), optCtrl=list(maxfun=2e5), calc.derivs=FALSE))
se = sqrt(diag(vcov(m11)))
# table of estimates with 95% CI
tab_m11 = cbind(Est = fixef(m11), LL = fixef(m11) - 1.96 * se, UL = fixef(m11) + 1.96 * se)
round(exp(tab_m11), digits = 3)[1:11,]

# output with p-values
tidy(m11) %>%
  select(term, estimate, std.error, p.value) %>%
  rename(Term = term, Estimate = estimate, SE = std.error, p = p.value) %>%
  mutate(Estimate = round(Estimate, 4),
         SE = round(SE, 4),
         p = round(p, 4)) %>%
  head(11) %>%
  kbl() %>%
    kable_styling(bootstrap_options = c("striped", "hover", "condensed"))
```

